/* tslint:disable */
/* eslint-disable */
/**
 * Dynamic API Specification
 * This is a dynamically generated API specification for all endpoints existing on the current project.
 *
 * The version of the OpenAPI document: 11.6.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AcceptInviteRequest
 */
export interface AcceptInviteRequest {
    /**
     * Accept invite token.
     * @type {string}
     * @memberof AcceptInviteRequest
     */
    'token'?: string;
    /**
     * Password of the user.
     * @type {string}
     * @memberof AcceptInviteRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * Unique identifier for the object.
     * @type {number}
     * @memberof Activity
     */
    'id'?: number;
    /**
     * Action that was performed.
     * @type {string}
     * @memberof Activity
     */
    'action'?: ActivityActionEnum;
    /**
     * 
     * @type {ActivityUser}
     * @memberof Activity
     */
    'user'?: ActivityUser | null;
    /**
     * When the action happened.
     * @type {string}
     * @memberof Activity
     */
    'timestamp'?: string;
    /**
     * 
     * @type {ActivityIp}
     * @memberof Activity
     */
    'ip'?: ActivityIp;
    /**
     * User agent string of the browser the user used when the action took place.
     * @type {string}
     * @memberof Activity
     */
    'user_agent'?: string;
    /**
     * 
     * @type {ActivityCollection}
     * @memberof Activity
     */
    'collection'?: ActivityCollection;
    /**
     * Unique identifier for the item the action applied to. This is always a string, even for integer primary keys.
     * @type {string}
     * @memberof Activity
     */
    'item'?: string;
    /**
     * Origin of the request when the action took place.
     * @type {string}
     * @memberof Activity
     */
    'origin'?: string;
    /**
     * 
     * @type {Array<ActivityRevisionsInner>}
     * @memberof Activity
     */
    'revisions'?: Array<ActivityRevisionsInner> | null;
}

export const ActivityActionEnum = {
    Create: 'create',
    Update: 'update',
    Delete: 'delete',
    Login: 'login'
} as const;

export type ActivityActionEnum = typeof ActivityActionEnum[keyof typeof ActivityActionEnum];

/**
 * @type ActivityCollection
 * Collection identifier in which the item resides.
 * @export
 */
export type ActivityCollection = Collections | string;

/**
 * @type ActivityIp
 * The IP address of the user at the time the action took place.
 * @export
 */
export type ActivityIp = string;

/**
 * @type ActivityRevisionsInner
 * @export
 */
export type ActivityRevisionsInner = Revisions | number;

/**
 * @type ActivityUser
 * The user who performed this action.
 * @export
 */
export type ActivityUser = Users | string;

/**
 * 
 * @export
 * @interface Collections
 */
export interface Collections {
    /**
     * The collection key.
     * @type {string}
     * @memberof Collections
     */
    'collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'display_template'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Collections
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Collections
     */
    'singleton'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof Collections
     */
    'translations'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'archive_field'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Collections
     */
    'archive_app_filter'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'archive_value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'unarchive_value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'sort_field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'accountability'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'color'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Collections
     */
    'item_duplication_fields'?: any | null;
    /**
     * 
     * @type {number}
     * @memberof Collections
     */
    'sort'?: number | null;
    /**
     * 
     * @type {CollectionsGroup}
     * @memberof Collections
     */
    'group'?: CollectionsGroup | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'collapse'?: string;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'preview_url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Collections
     */
    'versioning'?: boolean;
}
/**
 * @type CollectionsGroup
 * @export
 */
export type CollectionsGroup = Collections | string;

/**
 * 
 * @export
 * @interface Comments
 */
export interface Comments {
    /**
     * Unique identifier for this single collection preset.
     * @type {string}
     * @memberof Comments
     */
    'id'?: string;
    /**
     * 
     * @type {CommentsCollection}
     * @memberof Comments
     */
    'collection'?: CommentsCollection;
    /**
     * The item the Comment is created for.
     * @type {string}
     * @memberof Comments
     */
    'item'?: string;
    /**
     * User comment. This will store the comments that show up in the right sidebar of the item edit page in the admin app.
     * @type {string}
     * @memberof Comments
     */
    'comment'?: string;
    /**
     * When the Comment was created.
     * @type {string}
     * @memberof Comments
     */
    'date_created'?: string | null;
    /**
     * When the Comment was updated.
     * @type {string}
     * @memberof Comments
     */
    'date_updated'?: string | null;
    /**
     * 
     * @type {CommentsUserCreated}
     * @memberof Comments
     */
    'user_created'?: CommentsUserCreated;
    /**
     * 
     * @type {CommentsUserUpdated}
     * @memberof Comments
     */
    'user_updated'?: CommentsUserUpdated;
}
/**
 * @type CommentsCollection
 * The collection of the item the Comment is created for.
 * @export
 */
export type CommentsCollection = Collections | string;

/**
 * @type CommentsUserCreated
 * User that created the Comment.
 * @export
 */
export type CommentsUserCreated = Users | string;

/**
 * @type CommentsUserUpdated
 * User that updated the Comment.
 * @export
 */
export type CommentsUserUpdated = Users | string;

/**
 * 
 * @export
 * @interface CreateCollection200Response
 */
export interface CreateCollection200Response {
    /**
     * 
     * @type {Collections}
     * @memberof CreateCollection200Response
     */
    'data'?: Collections;
}
/**
 * 
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
    /**
     * Unique name of the collection.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'collection': string;
    /**
     * The fields contained in this collection. See the fields reference for more information. Each individual field requires field, type, and interface to be provided.
     * @type {Array<object>}
     * @memberof CreateCollectionRequest
     */
    'fields': Array<object>;
    /**
     * Name of a Google Material Design Icon that\'s assigned to this collection.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'icon'?: string | null;
    /**
     * A note describing the collection.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'note'?: string | null;
    /**
     * Text representation of how items from this collection are shown across the system.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'display_template'?: string | null;
    /**
     * Whether or not the collection is hidden from the navigation in the admin app.
     * @type {boolean}
     * @memberof CreateCollectionRequest
     */
    'hidden'?: boolean;
    /**
     * Whether or not the collection is treated as a single object.
     * @type {boolean}
     * @memberof CreateCollectionRequest
     */
    'singleton'?: boolean;
    /**
     * Key value pairs of how to show this collection\'s name in different languages in the admin app.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'translation'?: string | null;
    /**
     * Whether or not Content Versioning is enabled for this collection.
     * @type {boolean}
     * @memberof CreateCollectionRequest
     */
    'versioning'?: boolean;
    /**
     * What field holds the archive value.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'archive_field'?: string | null;
    /**
     * What value to use for \"archived\" items.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'archive_app_filter'?: string | null;
    /**
     * What value to use to \"unarchive\" items.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'archive_value'?: string | null;
    /**
     * Whether or not to show the \"archived\" filter.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'unarchive_value'?: string | null;
    /**
     * The sort field in the collection.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'sort_field'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateComment200Response
 */
export interface CreateComment200Response {
    /**
     * 
     * @type {Comments}
     * @memberof CreateComment200Response
     */
    'data'?: Comments;
}
/**
 * 
 * @export
 * @interface CreateCommentRequest
 */
export interface CreateCommentRequest {
    /**
     * Which collection this collection comment is for.
     * @type {string}
     * @memberof CreateCommentRequest
     */
    'collection': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequest
     */
    'item': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequest
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface CreateContentVersion200Response
 */
export interface CreateContentVersion200Response {
    /**
     * 
     * @type {Versions}
     * @memberof CreateContentVersion200Response
     */
    'data'?: Versions;
}
/**
 * 
 * @export
 * @interface CreateField200Response
 */
export interface CreateField200Response {
    /**
     * 
     * @type {Fields}
     * @memberof CreateField200Response
     */
    'data'?: Fields;
}
/**
 * 
 * @export
 * @interface CreateFieldRequest
 */
export interface CreateFieldRequest {
    /**
     * Unique name of the field. Field name is unique within the collection.
     * @type {string}
     * @memberof CreateFieldRequest
     */
    'field': string;
    /**
     * Directus specific data type. Used to cast values in the API.
     * @type {string}
     * @memberof CreateFieldRequest
     */
    'type': string;
    /**
     * 
     * @type {CreateFieldRequestSchema}
     * @memberof CreateFieldRequest
     */
    'schema'?: CreateFieldRequestSchema;
    /**
     * 
     * @type {CreateFieldRequestMeta}
     * @memberof CreateFieldRequest
     */
    'meta'?: CreateFieldRequestMeta | null;
}
/**
 * The meta info.
 * @export
 * @interface CreateFieldRequestMeta
 */
export interface CreateFieldRequestMeta {
    /**
     * Unique identifier for the field in the `directus_fields` collection.
     * @type {number}
     * @memberof CreateFieldRequestMeta
     */
    'id'?: number;
    /**
     * Unique name of the collection this field is in.
     * @type {string}
     * @memberof CreateFieldRequestMeta
     */
    'collection'?: string;
    /**
     * Unique name of the field. Field name is unique within the collection.
     * @type {string}
     * @memberof CreateFieldRequestMeta
     */
    'field'?: string;
    /**
     * Transformation flag for field
     * @type {Array<string>}
     * @memberof CreateFieldRequestMeta
     */
    'special'?: Array<string> | null;
    /**
     * What interface is used in the admin app to edit the value for this field.
     * @type {string}
     * @memberof CreateFieldRequestMeta
     */
    'system-interface'?: string | null;
    /**
     * Options for the interface that\'s used. This format is based on the individual interface.
     * @type {object}
     * @memberof CreateFieldRequestMeta
     */
    'options'?: object | null;
    /**
     * What display is used in the admin app to display the value for this field.
     * @type {string}
     * @memberof CreateFieldRequestMeta
     */
    'display'?: string | null;
    /**
     * Options for the display that\'s used. This format is based on the individual display.
     * @type {object}
     * @memberof CreateFieldRequestMeta
     */
    'display_options'?: object | null;
    /**
     * If the field can be altered by the end user. Directus system fields have this value set to `true`.
     * @type {boolean}
     * @memberof CreateFieldRequestMeta
     */
    'locked'?: boolean;
    /**
     * Prevents the user from editing the value in the field.
     * @type {boolean}
     * @memberof CreateFieldRequestMeta
     */
    'readonly'?: boolean;
    /**
     * If this field should be hidden.
     * @type {boolean}
     * @memberof CreateFieldRequestMeta
     */
    'hidden'?: boolean;
    /**
     * Sort order of this field on the edit page of the admin app.
     * @type {number}
     * @memberof CreateFieldRequestMeta
     */
    'sort'?: number | null;
    /**
     * Width of the field on the edit form.
     * @type {string}
     * @memberof CreateFieldRequestMeta
     */
    'width'?: CreateFieldRequestMetaWidthEnum | null;
    /**
     * What field group this field is part of.
     * @type {number}
     * @memberof CreateFieldRequestMeta
     */
    'group'?: number | null;
    /**
     * Key value pair of `<language>: <translation>` that allows the user to change the displayed name of the field in the admin app.
     * @type {object}
     * @memberof CreateFieldRequestMeta
     */
    'translation'?: object | null;
    /**
     * A user provided note for the field. Will be rendered alongside the interface on the edit page.
     * @type {string}
     * @memberof CreateFieldRequestMeta
     */
    'note'?: string | null;
}

export const CreateFieldRequestMetaWidthEnum = {
    Half: 'half',
    HalfLeft: 'half-left',
    HalfRight: 'half-right',
    Full: 'full',
    Fill: 'fill'
} as const;

export type CreateFieldRequestMetaWidthEnum = typeof CreateFieldRequestMetaWidthEnum[keyof typeof CreateFieldRequestMetaWidthEnum];

/**
 * The schema info.
 * @export
 * @interface CreateFieldRequestSchema
 */
export interface CreateFieldRequestSchema {
    /**
     * The name of the field.
     * @type {string}
     * @memberof CreateFieldRequestSchema
     */
    'name'?: string;
    /**
     * The collection of the field.
     * @type {string}
     * @memberof CreateFieldRequestSchema
     */
    'table'?: string;
    /**
     * The type of the field.
     * @type {string}
     * @memberof CreateFieldRequestSchema
     */
    'type'?: string;
    /**
     * The default value of the field.
     * @type {string}
     * @memberof CreateFieldRequestSchema
     */
    'default_value'?: string | null;
    /**
     * The max length of the field.
     * @type {number}
     * @memberof CreateFieldRequestSchema
     */
    'max_length'?: number | null;
    /**
     * If the field is nullable.
     * @type {boolean}
     * @memberof CreateFieldRequestSchema
     */
    'is_nullable'?: boolean;
    /**
     * If the field is primary key.
     * @type {boolean}
     * @memberof CreateFieldRequestSchema
     */
    'is_primary_key'?: boolean;
    /**
     * If the field has auto increment.
     * @type {boolean}
     * @memberof CreateFieldRequestSchema
     */
    'has_auto_increment'?: boolean;
    /**
     * Related column from the foreign key constraint.
     * @type {string}
     * @memberof CreateFieldRequestSchema
     */
    'foreign_key_column'?: string | null;
    /**
     * Related table from the foreign key constraint.
     * @type {string}
     * @memberof CreateFieldRequestSchema
     */
    'foreign_key_table'?: string | null;
    /**
     * Comment as saved in the database.
     * @type {string}
     * @memberof CreateFieldRequestSchema
     */
    'comment'?: string | null;
    /**
     * Database schema (pg only).
     * @type {string}
     * @memberof CreateFieldRequestSchema
     */
    'schema'?: string;
    /**
     * Related schema from the foreign key constraint (pg only).
     * @type {string}
     * @memberof CreateFieldRequestSchema
     */
    'foreign_key_schema'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateFile200Response
 */
export interface CreateFile200Response {
    /**
     * 
     * @type {Files}
     * @memberof CreateFile200Response
     */
    'data'?: Files;
}
/**
 * 
 * @export
 * @interface CreateFileRequest
 */
export interface CreateFileRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateFileRequest
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface CreateFlow200Response
 */
export interface CreateFlow200Response {
    /**
     * 
     * @type {Flows}
     * @memberof CreateFlow200Response
     */
    'data'?: Flows;
}
/**
 * 
 * @export
 * @interface CreateFolder200Response
 */
export interface CreateFolder200Response {
    /**
     * 
     * @type {Folders}
     * @memberof CreateFolder200Response
     */
    'data'?: Folders;
}
/**
 * 
 * @export
 * @interface CreateFolderRequest
 */
export interface CreateFolderRequest {
    /**
     * Name of the folder.
     * @type {string}
     * @memberof CreateFolderRequest
     */
    'name': string;
    /**
     * Unique identifier of the parent folder. This allows for nested folders.
     * @type {number}
     * @memberof CreateFolderRequest
     */
    'parent'?: number;
}
/**
 * 
 * @export
 * @interface CreateItemsArticles200Response
 */
export interface CreateItemsArticles200Response {
    /**
     * 
     * @type {Array<ItemsArticles>}
     * @memberof CreateItemsArticles200Response
     */
    'data'?: Array<ItemsArticles>;
}
/**
 * @type CreateItemsArticlesRequest
 * @export
 */
export type CreateItemsArticlesRequest = Array<ItemsArticles> | ItemsArticles;

/**
 * 
 * @export
 * @interface CreateItemsUsers200Response
 */
export interface CreateItemsUsers200Response {
    /**
     * 
     * @type {Array<ItemsUsers>}
     * @memberof CreateItemsUsers200Response
     */
    'data'?: Array<ItemsUsers>;
}
/**
 * @type CreateItemsUsersRequest
 * @export
 */
export type CreateItemsUsersRequest = Array<ItemsUsers> | ItemsUsers;

/**
 * 
 * @export
 * @interface CreateOperation200Response
 */
export interface CreateOperation200Response {
    /**
     * 
     * @type {Operations}
     * @memberof CreateOperation200Response
     */
    'data'?: Operations;
}
/**
 * 
 * @export
 * @interface CreatePermission200Response
 */
export interface CreatePermission200Response {
    /**
     * 
     * @type {Permissions}
     * @memberof CreatePermission200Response
     */
    'data'?: Permissions;
}
/**
 * 
 * @export
 * @interface CreatePermissionRequest
 */
export interface CreatePermissionRequest {
    /**
     * What collection this permission applies to.
     * @type {string}
     * @memberof CreatePermissionRequest
     */
    'collection'?: string;
    /**
     * If the user can post comments.
     * @type {string}
     * @memberof CreatePermissionRequest
     */
    'comment'?: CreatePermissionRequestCommentEnum;
    /**
     * If the user can create items.
     * @type {string}
     * @memberof CreatePermissionRequest
     */
    'create'?: CreatePermissionRequestCreateEnum;
    /**
     * If the user can update items.
     * @type {string}
     * @memberof CreatePermissionRequest
     */
    'delete'?: CreatePermissionRequestDeleteEnum;
    /**
     * If the user is required to leave a comment explaining what was changed.
     * @type {string}
     * @memberof CreatePermissionRequest
     */
    'explain'?: CreatePermissionRequestExplainEnum;
    /**
     * If the user can read items.
     * @type {string}
     * @memberof CreatePermissionRequest
     */
    'read'?: CreatePermissionRequestReadEnum;
    /**
     * Unique identifier of the role this permission applies to.
     * @type {number}
     * @memberof CreatePermissionRequest
     */
    'role'?: number;
    /**
     * Explicitly denies read access for specific fields.
     * @type {Array<string>}
     * @memberof CreatePermissionRequest
     */
    'read_field_blacklist'?: Array<string>;
    /**
     * What status this permission applies to.
     * @type {string}
     * @memberof CreatePermissionRequest
     */
    'status'?: string;
    /**
     * Explicitly denies specific statuses to be used.
     * @type {Array<string>}
     * @memberof CreatePermissionRequest
     */
    'status_blacklist'?: Array<string>;
    /**
     * If the user can update items.
     * @type {string}
     * @memberof CreatePermissionRequest
     */
    'update'?: CreatePermissionRequestUpdateEnum;
    /**
     * Explicitly denies write access for specific fields.
     * @type {Array<string>}
     * @memberof CreatePermissionRequest
     */
    'write_field_blacklist'?: Array<string>;
}

export const CreatePermissionRequestCommentEnum = {
    None: 'none',
    Create: 'create',
    Update: 'update',
    Full: 'full'
} as const;

export type CreatePermissionRequestCommentEnum = typeof CreatePermissionRequestCommentEnum[keyof typeof CreatePermissionRequestCommentEnum];
export const CreatePermissionRequestCreateEnum = {
    None: 'none',
    Full: 'full'
} as const;

export type CreatePermissionRequestCreateEnum = typeof CreatePermissionRequestCreateEnum[keyof typeof CreatePermissionRequestCreateEnum];
export const CreatePermissionRequestDeleteEnum = {
    None: 'none',
    Mine: 'mine',
    Role: 'role',
    Full: 'full'
} as const;

export type CreatePermissionRequestDeleteEnum = typeof CreatePermissionRequestDeleteEnum[keyof typeof CreatePermissionRequestDeleteEnum];
export const CreatePermissionRequestExplainEnum = {
    None: 'none',
    Create: 'create',
    Update: 'update',
    Always: 'always'
} as const;

export type CreatePermissionRequestExplainEnum = typeof CreatePermissionRequestExplainEnum[keyof typeof CreatePermissionRequestExplainEnum];
export const CreatePermissionRequestReadEnum = {
    None: 'none',
    Mine: 'mine',
    Role: 'role',
    Full: 'full'
} as const;

export type CreatePermissionRequestReadEnum = typeof CreatePermissionRequestReadEnum[keyof typeof CreatePermissionRequestReadEnum];
export const CreatePermissionRequestUpdateEnum = {
    None: 'none',
    Mine: 'mine',
    Role: 'role',
    Full: 'full'
} as const;

export type CreatePermissionRequestUpdateEnum = typeof CreatePermissionRequestUpdateEnum[keyof typeof CreatePermissionRequestUpdateEnum];

/**
 * 
 * @export
 * @interface CreatePreset200Response
 */
export interface CreatePreset200Response {
    /**
     * 
     * @type {Presets}
     * @memberof CreatePreset200Response
     */
    'data'?: Presets;
}
/**
 * 
 * @export
 * @interface CreatePresetRequest
 */
export interface CreatePresetRequest {
    /**
     * What collection this collection preset is used for.
     * @type {string}
     * @memberof CreatePresetRequest
     */
    'collection': string;
    /**
     * Name for the bookmark. If this is set, the collection preset will be considered to be a bookmark.
     * @type {string}
     * @memberof CreatePresetRequest
     */
    'title'?: string;
    /**
     * The unique identifier of a role in the platform. If user is null, this will be used to apply the collection preset or bookmark for all users in the role.
     * @type {string}
     * @memberof CreatePresetRequest
     */
    'role'?: string;
    /**
     * What the user searched for in search/filter in the header bar.
     * @type {string}
     * @memberof CreatePresetRequest
     */
    'search'?: string;
    /**
     * 
     * @type {Array<CreatePresetRequestFiltersInner>}
     * @memberof CreatePresetRequest
     */
    'filters'?: Array<CreatePresetRequestFiltersInner>;
    /**
     * Name of the view type that is used.
     * @type {string}
     * @memberof CreatePresetRequest
     */
    'layout'?: string;
    /**
     * Layout query that\'s saved per layout type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters.
     * @type {string}
     * @memberof CreatePresetRequest
     */
    'layout_query'?: string;
    /**
     * Options of the views. The properties in here are controlled by the layout.
     * @type {string}
     * @memberof CreatePresetRequest
     */
    'layout_options'?: string;
}
/**
 * 
 * @export
 * @interface CreatePresetRequestFiltersInner
 */
export interface CreatePresetRequestFiltersInner {
    /**
     * 
     * @type {string}
     * @memberof CreatePresetRequestFiltersInner
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePresetRequestFiltersInner
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePresetRequestFiltersInner
     */
    'operator'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreatePresetRequestFiltersInner
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CreateRelation200Response
 */
export interface CreateRelation200Response {
    /**
     * 
     * @type {Relations}
     * @memberof CreateRelation200Response
     */
    'data'?: Relations;
}
/**
 * 
 * @export
 * @interface CreateRelationRequest
 */
export interface CreateRelationRequest {
    /**
     * Collection that has the field that holds the foreign key.
     * @type {string}
     * @memberof CreateRelationRequest
     */
    'collection_many'?: string;
    /**
     * Collection on the _one_ side of the relationship.
     * @type {string}
     * @memberof CreateRelationRequest
     */
    'collection_one'?: string;
    /**
     * Foreign key. Field that holds the primary key of the related collection.
     * @type {string}
     * @memberof CreateRelationRequest
     */
    'field_many'?: string;
    /**
     * Alias column that serves as the _one_ side of the relationship.
     * @type {string}
     * @memberof CreateRelationRequest
     */
    'field_one'?: string;
    /**
     * Field on the junction table that holds the primary key of the related collection.
     * @type {string}
     * @memberof CreateRelationRequest
     */
    'junction_field'?: string;
}
/**
 * 
 * @export
 * @interface CreateRole200Response
 */
export interface CreateRole200Response {
    /**
     * 
     * @type {Roles}
     * @memberof CreateRole200Response
     */
    'data'?: Roles;
}
/**
 * 
 * @export
 * @interface CreateRoleRequest
 */
export interface CreateRoleRequest {
    /**
     * Description of the role.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    'description'?: string;
    /**
     * Whether or not this role enforces the use of 2FA.
     * @type {boolean}
     * @memberof CreateRoleRequest
     */
    'enforce_tfa'?: boolean;
    /**
     * ID used with external services in SCIM.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    'external_id'?: string;
    /**
     * Array of IP addresses that are allowed to connect to the API as a user of this role.
     * @type {Array<string>}
     * @memberof CreateRoleRequest
     */
    'ip_access'?: Array<string>;
    /**
     * Custom override for the admin app module bar navigation.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    'module_listing'?: string;
    /**
     * Name of the role.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateUser200Response
 */
export interface CreateUser200Response {
    /**
     * 
     * @type {Users}
     * @memberof CreateUser200Response
     */
    'data'?: Users;
}
/**
 * 
 * @export
 * @interface CreateWebhookRequest
 */
export interface CreateWebhookRequest {
    /**
     * The name of the webhook.
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'name'?: string;
    /**
     * Method used in the webhook.
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'method'?: string;
    /**
     * The url of the webhook.
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'url'?: string;
    /**
     * The status of the webhook.
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'status'?: string;
    /**
     * If yes, send the content of what was done
     * @type {boolean}
     * @memberof CreateWebhookRequest
     */
    'data'?: boolean;
    /**
     * The actions that triggers this webhook.
     * @type {any}
     * @memberof CreateWebhookRequest
     */
    'actions'?: any;
    /**
     * The collections that triggers this webhook.
     * @type {any}
     * @memberof CreateWebhookRequest
     */
    'system-collections'?: any;
}
/**
 * 
 * @export
 * @interface Diff
 */
export interface Diff {
    /**
     * 
     * @type {string}
     * @memberof Diff
     */
    'hash'?: string;
    /**
     * 
     * @type {DiffDiff}
     * @memberof Diff
     */
    'diff'?: DiffDiff;
}
/**
 * 
 * @export
 * @interface DiffDiff
 */
export interface DiffDiff {
    /**
     * 
     * @type {Array<DiffDiffCollectionsInner>}
     * @memberof DiffDiff
     */
    'collections'?: Array<DiffDiffCollectionsInner>;
    /**
     * 
     * @type {Array<DiffDiffFieldsInner>}
     * @memberof DiffDiff
     */
    'fields'?: Array<DiffDiffFieldsInner>;
    /**
     * 
     * @type {Array<DiffDiffRelationsInner>}
     * @memberof DiffDiff
     */
    'relations'?: Array<DiffDiffRelationsInner>;
}
/**
 * 
 * @export
 * @interface DiffDiffCollectionsInner
 */
export interface DiffDiffCollectionsInner {
    /**
     * 
     * @type {string}
     * @memberof DiffDiffCollectionsInner
     */
    'collection'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof DiffDiffCollectionsInner
     */
    'diff'?: Array<object>;
}
/**
 * 
 * @export
 * @interface DiffDiffFieldsInner
 */
export interface DiffDiffFieldsInner {
    /**
     * 
     * @type {string}
     * @memberof DiffDiffFieldsInner
     */
    'collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiffDiffFieldsInner
     */
    'field'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof DiffDiffFieldsInner
     */
    'diff'?: Array<object>;
}
/**
 * 
 * @export
 * @interface DiffDiffRelationsInner
 */
export interface DiffDiffRelationsInner {
    /**
     * 
     * @type {string}
     * @memberof DiffDiffRelationsInner
     */
    'collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiffDiffRelationsInner
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiffDiffRelationsInner
     */
    'related_collection'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof DiffDiffRelationsInner
     */
    'diff'?: Array<object>;
}
/**
 * 
 * @export
 * @interface ExportRequest
 */
export interface ExportRequest {
    /**
     * What file format to save the export to. One of csv, xml, json
     * @type {string}
     * @memberof ExportRequest
     */
    'format': ExportRequestFormatEnum;
    /**
     * 
     * @type {Query}
     * @memberof ExportRequest
     */
    'query': Query;
    /**
     * 
     * @type {Files}
     * @memberof ExportRequest
     */
    'file': Files;
}

export const ExportRequestFormatEnum = {
    Csv: 'csv',
    Xml: 'xml',
    Json: 'json'
} as const;

export type ExportRequestFormatEnum = typeof ExportRequestFormatEnum[keyof typeof ExportRequestFormatEnum];

/**
 * 
 * @export
 * @interface Extensions
 */
export interface Extensions {
    /**
     * 
     * @type {boolean}
     * @memberof Extensions
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Extensions
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Extensions
     */
    'folder'?: string;
    /**
     * 
     * @type {string}
     * @memberof Extensions
     */
    'source'?: string;
    /**
     * Name of the bundle the extension is in.
     * @type {string}
     * @memberof Extensions
     */
    'bundle'?: string | null;
}
/**
 * 
 * @export
 * @interface Fields
 */
export interface Fields {
    /**
     * 
     * @type {number}
     * @memberof Fields
     */
    'id'?: number;
    /**
     * Unique name of the collection this field is in.
     * @type {string}
     * @memberof Fields
     */
    'collection'?: string;
    /**
     * Unique name of the field. Field name is unique within the collection.
     * @type {string}
     * @memberof Fields
     */
    'field'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fields
     */
    'special'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof Fields
     */
    'interface'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Fields
     */
    'options'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof Fields
     */
    'display'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Fields
     */
    'display_options'?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof Fields
     */
    'readonly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Fields
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Fields
     */
    'sort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Fields
     */
    'width'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Fields
     */
    'translations'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof Fields
     */
    'note'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Fields
     */
    'conditions'?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof Fields
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {FieldsGroup}
     * @memberof Fields
     */
    'group'?: FieldsGroup | null;
    /**
     * 
     * @type {any}
     * @memberof Fields
     */
    'validation'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof Fields
     */
    'validation_message'?: string | null;
}
/**
 * @type FieldsGroup
 * @export
 */
export type FieldsGroup = Fields | number;

/**
 * 
 * @export
 * @interface Files
 */
export interface Files {
    /**
     * Unique identifier for the file.
     * @type {string}
     * @memberof Files
     */
    'id'?: string;
    /**
     * Where the file is stored. Either `local` for the local filesystem or the name of the storage adapter (for example `s3`).
     * @type {string}
     * @memberof Files
     */
    'storage'?: string;
    /**
     * Name of the file on disk. By default, Directus uses a random hash for the filename.
     * @type {string}
     * @memberof Files
     */
    'filename_disk'?: string;
    /**
     * How you want to the file to be named when it\'s being downloaded.
     * @type {string}
     * @memberof Files
     */
    'filename_download'?: string;
    /**
     * Title for the file. Is extracted from the filename on upload, but can be edited by the user.
     * @type {string}
     * @memberof Files
     */
    'title'?: string;
    /**
     * MIME type of the file.
     * @type {string}
     * @memberof Files
     */
    'type'?: string;
    /**
     * 
     * @type {UpdateFileRequestFolder}
     * @memberof Files
     */
    'folder'?: UpdateFileRequestFolder | null;
    /**
     * 
     * @type {FilesUploadedBy}
     * @memberof Files
     */
    'uploaded_by'?: FilesUploadedBy;
    /**
     * When the file was created.
     * @type {string}
     * @memberof Files
     */
    'created_on'?: string;
    /**
     * 
     * @type {FilesModifiedBy}
     * @memberof Files
     */
    'modified_by'?: FilesModifiedBy | null;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'modified_on'?: string;
    /**
     * Character set of the file.
     * @type {string}
     * @memberof Files
     */
    'charset'?: string | null;
    /**
     * Size of the file in bytes.
     * @type {number}
     * @memberof Files
     */
    'filesize'?: number;
    /**
     * Width of the file in pixels. Only applies to images.
     * @type {number}
     * @memberof Files
     */
    'width'?: number | null;
    /**
     * Height of the file in pixels. Only applies to images.
     * @type {number}
     * @memberof Files
     */
    'height'?: number | null;
    /**
     * Duration of the file in seconds. Only applies to audio and video.
     * @type {number}
     * @memberof Files
     */
    'duration'?: number | null;
    /**
     * Where the file was embedded from.
     * @type {string}
     * @memberof Files
     */
    'embed'?: string | null;
    /**
     * Description for the file.
     * @type {string}
     * @memberof Files
     */
    'description'?: string | null;
    /**
     * Where the file was created. Is automatically populated based on Exif data for images.
     * @type {string}
     * @memberof Files
     */
    'location'?: string | null;
    /**
     * Tags for the file. Is automatically populated based on Exif data for images.
     * @type {Array<string>}
     * @memberof Files
     */
    'tags'?: Array<string> | null;
    /**
     * IPTC, Exif, and ICC metadata extracted from file
     * @type {object}
     * @memberof Files
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof Files
     */
    'focal_point_x'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Files
     */
    'focal_point_y'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'tus_id'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Files
     */
    'tus_data'?: any | null;
    /**
     * When the file was last uploaded/replaced.
     * @type {string}
     * @memberof Files
     */
    'uploaded_on'?: string;
}
/**
 * @type FilesModifiedBy
 * @export
 */
export type FilesModifiedBy = Users | string;

/**
 * @type FilesUploadedBy
 * Who uploaded the file.
 * @export
 */
export type FilesUploadedBy = Users | string;

/**
 * 
 * @export
 * @interface Flows
 */
export interface Flows {
    /**
     * Unique identifier for the flow.
     * @type {string}
     * @memberof Flows
     */
    'id'?: string;
    /**
     * The name of the flow.
     * @type {string}
     * @memberof Flows
     */
    'name'?: string;
    /**
     * Icon displayed in the Admin App for the flow.
     * @type {string}
     * @memberof Flows
     */
    'icon'?: string;
    /**
     * Color of the icon displayed in the Admin App for the flow.
     * @type {string}
     * @memberof Flows
     */
    'color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Flows
     */
    'description'?: string | null;
    /**
     * Current status of the flow.
     * @type {string}
     * @memberof Flows
     */
    'status'?: FlowsStatusEnum;
    /**
     * Type of trigger for the flow. One of `hook`, `webhook`, `operation`, `schedule`, `manual`.
     * @type {string}
     * @memberof Flows
     */
    'trigger'?: string;
    /**
     * The permission used during the flow. One of `$public`, `$trigger`, `$full`, or UUID of a role.
     * @type {string}
     * @memberof Flows
     */
    'accountability'?: string;
    /**
     * Options of the selected trigger for the flow.
     * @type {object}
     * @memberof Flows
     */
    'options'?: object | null;
    /**
     * 
     * @type {FlowsOperation}
     * @memberof Flows
     */
    'operation'?: FlowsOperation;
    /**
     * Timestamp in ISO8601 when the flow was created.
     * @type {string}
     * @memberof Flows
     */
    'date_created'?: string | null;
    /**
     * 
     * @type {FlowsUserCreated}
     * @memberof Flows
     */
    'user_created'?: FlowsUserCreated;
    /**
     * 
     * @type {Array<FlowsOperationsInner>}
     * @memberof Flows
     */
    'operations'?: Array<FlowsOperationsInner> | null;
}

export const FlowsStatusEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type FlowsStatusEnum = typeof FlowsStatusEnum[keyof typeof FlowsStatusEnum];

/**
 * @type FlowsOperation
 * UUID of the operation connected to the trigger in the flow.
 * @export
 */
export type FlowsOperation = Operations | string;

/**
 * @type FlowsOperationsInner
 * @export
 */
export type FlowsOperationsInner = Operations | string;

/**
 * @type FlowsUserCreated
 * The user who created the flow.
 * @export
 */
export type FlowsUserCreated = Users | string;

/**
 * 
 * @export
 * @interface Folders
 */
export interface Folders {
    /**
     * Unique identifier for the folder.
     * @type {string}
     * @memberof Folders
     */
    'id'?: string;
    /**
     * Name of the folder.
     * @type {string}
     * @memberof Folders
     */
    'name'?: string;
    /**
     * 
     * @type {FoldersParent}
     * @memberof Folders
     */
    'parent'?: FoldersParent | null;
}
/**
 * @type FoldersParent
 * Unique identifier of the parent folder. This allows for nested folders.
 * @export
 */
export type FoldersParent = Folders | string;

/**
 * 
 * @export
 * @interface GetActivities200Response
 */
export interface GetActivities200Response {
    /**
     * 
     * @type {Array<Activity>}
     * @memberof GetActivities200Response
     */
    'data'?: Array<Activity>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetActivities200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetActivity200Response
 */
export interface GetActivity200Response {
    /**
     * 
     * @type {Activity}
     * @memberof GetActivity200Response
     */
    'data'?: Activity;
}
/**
 * 
 * @export
 * @interface GetAsset404Response
 */
export interface GetAsset404Response {
    /**
     * 
     * @type {GetAsset404ResponseError}
     * @memberof GetAsset404Response
     */
    'error'?: GetAsset404ResponseError;
}
/**
 * 
 * @export
 * @interface GetAsset404ResponseError
 */
export interface GetAsset404ResponseError {
    /**
     * 
     * @type {number}
     * @memberof GetAsset404ResponseError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetAsset404ResponseError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetCollections200Response
 */
export interface GetCollections200Response {
    /**
     * 
     * @type {Array<Collections>}
     * @memberof GetCollections200Response
     */
    'data'?: Array<Collections>;
}
/**
 * 
 * @export
 * @interface GetComments200Response
 */
export interface GetComments200Response {
    /**
     * 
     * @type {Array<Comments>}
     * @memberof GetComments200Response
     */
    'data'?: Array<Comments>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetComments200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetContentVersions200Response
 */
export interface GetContentVersions200Response {
    /**
     * 
     * @type {Array<Versions>}
     * @memberof GetContentVersions200Response
     */
    'data'?: Array<Versions>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetContentVersions200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetFields200Response
 */
export interface GetFields200Response {
    /**
     * 
     * @type {Array<Fields>}
     * @memberof GetFields200Response
     */
    'data'?: Array<Fields>;
}
/**
 * 
 * @export
 * @interface GetFiles200Response
 */
export interface GetFiles200Response {
    /**
     * 
     * @type {Array<Files>}
     * @memberof GetFiles200Response
     */
    'data'?: Array<Files>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetFiles200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetFlows200Response
 */
export interface GetFlows200Response {
    /**
     * 
     * @type {Array<Flows>}
     * @memberof GetFlows200Response
     */
    'data'?: Array<Flows>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetFlows200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetFolders200Response
 */
export interface GetFolders200Response {
    /**
     * 
     * @type {Array<Folders>}
     * @memberof GetFolders200Response
     */
    'data'?: Array<Folders>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetFolders200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetMyPermissions200Response
 */
export interface GetMyPermissions200Response {
    /**
     * 
     * @type {Array<Permissions>}
     * @memberof GetMyPermissions200Response
     */
    'data'?: Array<Permissions>;
}
/**
 * 
 * @export
 * @interface GetOperations200Response
 */
export interface GetOperations200Response {
    /**
     * 
     * @type {Array<Operations>}
     * @memberof GetOperations200Response
     */
    'data'?: Array<Operations>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetOperations200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetPermissions200Response
 */
export interface GetPermissions200Response {
    /**
     * 
     * @type {Array<Permissions>}
     * @memberof GetPermissions200Response
     */
    'data'?: Array<Permissions>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetPermissions200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetPresets200Response
 */
export interface GetPresets200Response {
    /**
     * 
     * @type {Array<Presets>}
     * @memberof GetPresets200Response
     */
    'data'?: Array<Presets>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetPresets200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetRelations200Response
 */
export interface GetRelations200Response {
    /**
     * 
     * @type {Array<Relations>}
     * @memberof GetRelations200Response
     */
    'data'?: Array<Relations>;
}
/**
 * 
 * @export
 * @interface GetRevision200Response
 */
export interface GetRevision200Response {
    /**
     * 
     * @type {Revisions}
     * @memberof GetRevision200Response
     */
    'data'?: Revisions;
}
/**
 * 
 * @export
 * @interface GetRevisions200Response
 */
export interface GetRevisions200Response {
    /**
     * 
     * @type {Array<Revisions>}
     * @memberof GetRevisions200Response
     */
    'data'?: Array<Revisions>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetRevisions200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetRoles200Response
 */
export interface GetRoles200Response {
    /**
     * 
     * @type {Array<Roles>}
     * @memberof GetRoles200Response
     */
    'data'?: Array<Roles>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetRoles200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetSettings200Response
 */
export interface GetSettings200Response {
    /**
     * 
     * @type {Settings}
     * @memberof GetSettings200Response
     */
    'data'?: Settings;
}
/**
 * 
 * @export
 * @interface GetUsers200Response
 */
export interface GetUsers200Response {
    /**
     * 
     * @type {Array<Users>}
     * @memberof GetUsers200Response
     */
    'data'?: Array<Users>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetUsers200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetWebhooks200Response
 */
export interface GetWebhooks200Response {
    /**
     * 
     * @type {Webhooks}
     * @memberof GetWebhooks200Response
     */
    'data'?: Webhooks;
}
/**
 * 
 * @export
 * @interface HashGenerate200Response
 */
export interface HashGenerate200Response {
    /**
     * 
     * @type {string}
     * @memberof HashGenerate200Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface HashGenerateRequest
 */
export interface HashGenerateRequest {
    /**
     * String to hash.
     * @type {string}
     * @memberof HashGenerateRequest
     */
    'string': string;
}
/**
 * 
 * @export
 * @interface HashVerify200Response
 */
export interface HashVerify200Response {
    /**
     * 
     * @type {boolean}
     * @memberof HashVerify200Response
     */
    'data'?: boolean;
}
/**
 * 
 * @export
 * @interface HashVerifyRequest
 */
export interface HashVerifyRequest {
    /**
     * String to hash.
     * @type {string}
     * @memberof HashVerifyRequest
     */
    'string': string;
    /**
     * Hash you want to verify against.
     * @type {string}
     * @memberof HashVerifyRequest
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface InviteRequest
 */
export interface InviteRequest {
    /**
     * Email address or array of email addresses of the to-be-invited user(s).
     * @type {string}
     * @memberof InviteRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface ItemsArticles
 */
export interface ItemsArticles {
    /**
     * 
     * @type {number}
     * @memberof ItemsArticles
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticles
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemsArticles
     */
    'sort'?: number | null;
    /**
     * 
     * @type {FilesModifiedBy}
     * @memberof ItemsArticles
     */
    'user_created'?: FilesModifiedBy | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticles
     */
    'date_created'?: string | null;
    /**
     * 
     * @type {FilesModifiedBy}
     * @memberof ItemsArticles
     */
    'user_updated'?: FilesModifiedBy | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticles
     */
    'date_updated'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticles
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticles
     */
    'content'?: string | null;
}
/**
 * 
 * @export
 * @interface ItemsUsers
 */
export interface ItemsUsers {
    /**
     * 
     * @type {number}
     * @memberof ItemsUsers
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemsUsers
     */
    'sort'?: number | null;
    /**
     * 
     * @type {FilesModifiedBy}
     * @memberof ItemsUsers
     */
    'user_created'?: FilesModifiedBy | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsUsers
     */
    'date_created'?: string | null;
    /**
     * 
     * @type {FilesModifiedBy}
     * @memberof ItemsUsers
     */
    'user_updated'?: FilesModifiedBy | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsUsers
     */
    'date_updated'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsUsers
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsUsers
     */
    'password'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsUsers
     */
    'role'?: string | null;
}
/**
 * 
 * @export
 * @interface ListExtensions200Response
 */
export interface ListExtensions200Response {
    /**
     * 
     * @type {Array<Extensions>}
     * @memberof ListExtensions200Response
     */
    'data'?: Array<Extensions>;
}
/**
 * 
 * @export
 * @interface Login200Response
 */
export interface Login200Response {
    /**
     * 
     * @type {Login200ResponseData}
     * @memberof Login200Response
     */
    'data'?: Login200ResponseData;
}
/**
 * 
 * @export
 * @interface Login200ResponseData
 */
export interface Login200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof Login200ResponseData
     */
    'access_token'?: string;
    /**
     * 
     * @type {number}
     * @memberof Login200ResponseData
     */
    'expires'?: number;
    /**
     * 
     * @type {string}
     * @memberof Login200ResponseData
     */
    'refresh_token'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * Email address of the user you\'re retrieving the access token for.
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * Password of the user.
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
    /**
     * Whether to retrieve the refresh token in the JSON response, or in a httpOnly cookie.
     * @type {string}
     * @memberof LoginRequest
     */
    'mode'?: LoginRequestModeEnum;
    /**
     * The user\'s one-time-password (if MFA is enabled).
     * @type {string}
     * @memberof LoginRequest
     */
    'otp'?: string;
}

export const LoginRequestModeEnum = {
    Json: 'json',
    Cookie: 'cookie',
    Session: 'session'
} as const;

export type LoginRequestModeEnum = typeof LoginRequestModeEnum[keyof typeof LoginRequestModeEnum];

/**
 * 
 * @export
 * @interface LogoutRequest
 */
export interface LogoutRequest {
    /**
     * The refresh token to invalidate. If you have the refresh token in a cookie through /auth/login, you don\'t have to submit it here.
     * @type {string}
     * @memberof LogoutRequest
     */
    'refresh_token'?: string;
    /**
     * Whether the refresh token is submitted in the JSON response, or in a httpOnly cookie.
     * @type {string}
     * @memberof LogoutRequest
     */
    'mode'?: LogoutRequestModeEnum;
}

export const LogoutRequestModeEnum = {
    Json: 'json',
    Cookie: 'cookie',
    Session: 'session'
} as const;

export type LogoutRequestModeEnum = typeof LogoutRequestModeEnum[keyof typeof LogoutRequestModeEnum];

/**
 * 
 * @export
 * @interface Oauth200Response
 */
export interface Oauth200Response {
    /**
     * 
     * @type {boolean}
     * @memberof Oauth200Response
     */
    'public'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Oauth200Response
     */
    'data'?: Array<string>;
}
/**
 * 
 * @export
 * @interface OauthProvider200Response
 */
export interface OauthProvider200Response {
    /**
     * 
     * @type {boolean}
     * @memberof OauthProvider200Response
     */
    'public'?: boolean;
    /**
     * 
     * @type {OauthProvider200ResponseData}
     * @memberof OauthProvider200Response
     */
    'data'?: OauthProvider200ResponseData;
}
/**
 * 
 * @export
 * @interface OauthProvider200ResponseData
 */
export interface OauthProvider200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof OauthProvider200ResponseData
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Operations
 */
export interface Operations {
    /**
     * Unique identifier for the operation.
     * @type {string}
     * @memberof Operations
     */
    'id'?: string;
    /**
     * The name of the operation.
     * @type {string}
     * @memberof Operations
     */
    'name'?: string;
    /**
     * Key for the operation. Must be unique within a given flow.
     * @type {string}
     * @memberof Operations
     */
    'key'?: string;
    /**
     * Type of operation. One of `log`, `mail`, `notification`, `create`, `read`, `request`, `sleep`, `transform`, `trigger`, `condition`, or any type of custom operation extensions.
     * @type {string}
     * @memberof Operations
     */
    'type'?: string;
    /**
     * Position of the operation on the X axis within the flow workspace.
     * @type {number}
     * @memberof Operations
     */
    'position_x'?: number;
    /**
     * Position of the operation on the Y axis within the flow workspace.
     * @type {number}
     * @memberof Operations
     */
    'position_y'?: number;
    /**
     * Options depending on the type of the operation.
     * @type {object}
     * @memberof Operations
     */
    'options'?: object | null;
    /**
     * 
     * @type {OperationsResolve}
     * @memberof Operations
     */
    'resolve'?: OperationsResolve;
    /**
     * 
     * @type {OperationsReject}
     * @memberof Operations
     */
    'reject'?: OperationsReject;
    /**
     * 
     * @type {OperationsFlow}
     * @memberof Operations
     */
    'flow'?: OperationsFlow;
    /**
     * Timestamp in ISO8601 when the operation was created.
     * @type {string}
     * @memberof Operations
     */
    'date_created'?: string | null;
    /**
     * 
     * @type {OperationsUserCreated}
     * @memberof Operations
     */
    'user_created'?: OperationsUserCreated;
}
/**
 * @type OperationsFlow
 * @export
 */
export type OperationsFlow = Flows | string;

/**
 * @type OperationsReject
 * The operation triggered when the current operation fails (or `otherwise` logic of a condition operation).
 * @export
 */
export type OperationsReject = Operations | string;

/**
 * @type OperationsResolve
 * The operation triggered when the current operation succeeds (or `then` logic of a condition operation).
 * @export
 */
export type OperationsResolve = Operations | string;

/**
 * @type OperationsUserCreated
 * The user who created the operation.
 * @export
 */
export type OperationsUserCreated = Users | string;

/**
 * 
 * @export
 * @interface PasswordRequestRequest
 */
export interface PasswordRequestRequest {
    /**
     * Email address of the user you\'re requesting a reset for.
     * @type {string}
     * @memberof PasswordRequestRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface PasswordResetRequest
 */
export interface PasswordResetRequest {
    /**
     * One-time use JWT token that is used to verify the user.
     * @type {string}
     * @memberof PasswordResetRequest
     */
    'token': string;
    /**
     * New password for the user.
     * @type {string}
     * @memberof PasswordResetRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Permissions
 */
export interface Permissions {
    /**
     * Unique identifier for the permission.
     * @type {number}
     * @memberof Permissions
     */
    'id'?: number;
    /**
     * What collection this permission applies to.
     * @type {string}
     * @memberof Permissions
     */
    'collection'?: string;
    /**
     * What action this permission applies to.
     * @type {string}
     * @memberof Permissions
     */
    'action'?: PermissionsActionEnum;
    /**
     * JSON structure containing the permissions checks for this permission.
     * @type {object}
     * @memberof Permissions
     */
    'permissions'?: object | null;
    /**
     * JSON structure containing the validation checks for this permission.
     * @type {object}
     * @memberof Permissions
     */
    'validation'?: object | null;
    /**
     * JSON structure containing the preset value for created/updated items.
     * @type {object}
     * @memberof Permissions
     */
    'presets'?: object | null;
    /**
     * CSV of fields that the user is allowed to interact with.
     * @type {Array<string>}
     * @memberof Permissions
     */
    'fields'?: Array<string> | null;
    /**
     * 
     * @type {any}
     * @memberof Permissions
     */
    'policy'?: any;
}

export const PermissionsActionEnum = {
    Create: 'create',
    Read: 'read',
    Update: 'update',
    Delete: 'delete'
} as const;

export type PermissionsActionEnum = typeof PermissionsActionEnum[keyof typeof PermissionsActionEnum];

/**
 * 
 * @export
 * @interface Presets
 */
export interface Presets {
    /**
     * Unique identifier for this single collection preset.
     * @type {number}
     * @memberof Presets
     */
    'id'?: number;
    /**
     * Name for the bookmark. If this is set, the preset will be considered a bookmark.
     * @type {string}
     * @memberof Presets
     */
    'bookmark'?: string | null;
    /**
     * 
     * @type {PresetsUser}
     * @memberof Presets
     */
    'user'?: PresetsUser | null;
    /**
     * 
     * @type {PresetsRole}
     * @memberof Presets
     */
    'role'?: PresetsRole | null;
    /**
     * 
     * @type {PresetsCollection}
     * @memberof Presets
     */
    'collection'?: PresetsCollection;
    /**
     * Search query.
     * @type {string}
     * @memberof Presets
     */
    'search'?: string | null;
    /**
     * Key of the layout that is used.
     * @type {string}
     * @memberof Presets
     */
    'layout'?: string;
    /**
     * Layout query that\'s saved per layout type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters.
     * @type {any}
     * @memberof Presets
     */
    'layout_query'?: any | null;
    /**
     * Options of the views. The properties in here are controlled by the layout.
     * @type {any}
     * @memberof Presets
     */
    'layout_options'?: any | null;
    /**
     * 
     * @type {number}
     * @memberof Presets
     */
    'refresh_interval'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof Presets
     */
    'filter'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof Presets
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Presets
     */
    'color'?: string | null;
}
/**
 * @type PresetsCollection
 * What collection this collection preset is used for.
 * @export
 */
export type PresetsCollection = Collections | string;

/**
 * @type PresetsRole
 * The unique identifier of a role in the platform. If `user` is null, this will be used to apply the collection preset or bookmark for all users in the role.
 * @export
 */
export type PresetsRole = Roles | string;

/**
 * @type PresetsUser
 * The unique identifier of the user to whom this collection preset applies.
 * @export
 */
export type PresetsUser = Users | string;

/**
 * 
 * @export
 * @interface PromoteContentVersionRequest
 */
export interface PromoteContentVersionRequest {
    /**
     * Hash of the main version of the item to be promoted.
     * @type {string}
     * @memberof PromoteContentVersionRequest
     */
    'mainHash'?: string;
    /**
     * Optional array of field names of which the values are to be promoted.
     * @type {string}
     * @memberof PromoteContentVersionRequest
     */
    'fields'?: string;
}
/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * Control what fields are being returned in the object.
     * @type {Array<string>}
     * @memberof Query
     */
    'fields'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof Query
     */
    'filter'?: object;
    /**
     * Filter by items that contain the given search query in one of their fields.
     * @type {string}
     * @memberof Query
     */
    'search'?: string;
    /**
     * How to sort the returned items.
     * @type {Array<string>}
     * @memberof Query
     */
    'sort'?: Array<string>;
    /**
     * Set the maximum number of items that will be returned
     * @type {number}
     * @memberof Query
     */
    'limit'?: number;
    /**
     * How many items to skip when fetching data.
     * @type {number}
     * @memberof Query
     */
    'offset'?: number;
    /**
     * Cursor for use in pagination. Often used in combination with limit.
     * @type {number}
     * @memberof Query
     */
    'page'?: number;
    /**
     * Deep allows you to set any of the other query parameters on a nested relational dataset.
     * @type {object}
     * @memberof Query
     */
    'deep'?: object;
}
/**
 * 
 * @export
 * @interface Random200Response
 */
export interface Random200Response {
    /**
     * 
     * @type {string}
     * @memberof Random200Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface ReadItemsArticles200Response
 */
export interface ReadItemsArticles200Response {
    /**
     * 
     * @type {Array<ItemsArticles>}
     * @memberof ReadItemsArticles200Response
     */
    'data'?: Array<ItemsArticles>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsArticles200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsUsers200Response
 */
export interface ReadItemsUsers200Response {
    /**
     * 
     * @type {Array<ItemsUsers>}
     * @memberof ReadItemsUsers200Response
     */
    'data'?: Array<ItemsUsers>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsUsers200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsArticles200Response
 */
export interface ReadSingleItemsArticles200Response {
    /**
     * 
     * @type {ItemsArticles}
     * @memberof ReadSingleItemsArticles200Response
     */
    'data'?: ItemsArticles;
}
/**
 * @type ReadSingleItemsArticlesIdParameter
 * @export
 */
export type ReadSingleItemsArticlesIdParameter = number | string;

/**
 * 
 * @export
 * @interface ReadSingleItemsUsers200Response
 */
export interface ReadSingleItemsUsers200Response {
    /**
     * 
     * @type {ItemsUsers}
     * @memberof ReadSingleItemsUsers200Response
     */
    'data'?: ItemsUsers;
}
/**
 * 
 * @export
 * @interface Refresh200Response
 */
export interface Refresh200Response {
    /**
     * 
     * @type {Refresh200ResponseData}
     * @memberof Refresh200Response
     */
    'data'?: Refresh200ResponseData;
}
/**
 * 
 * @export
 * @interface Refresh200ResponseData
 */
export interface Refresh200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof Refresh200ResponseData
     */
    'access_token'?: string;
    /**
     * 
     * @type {number}
     * @memberof Refresh200ResponseData
     */
    'expires'?: number;
    /**
     * 
     * @type {string}
     * @memberof Refresh200ResponseData
     */
    'refresh_token'?: string;
}
/**
 * 
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
    /**
     * JWT access token you want to refresh. This token can\'t be expired.
     * @type {string}
     * @memberof RefreshRequest
     */
    'refresh_token'?: string;
    /**
     * Whether to submit and retrieve the refresh token in the JSON response, or in a httpOnly cookie.
     * @type {string}
     * @memberof RefreshRequest
     */
    'mode'?: RefreshRequestModeEnum;
}

export const RefreshRequestModeEnum = {
    Json: 'json',
    Cookie: 'cookie',
    Session: 'session'
} as const;

export type RefreshRequestModeEnum = typeof RefreshRequestModeEnum[keyof typeof RefreshRequestModeEnum];

/**
 * 
 * @export
 * @interface Relations
 */
export interface Relations {
    /**
     * Unique identifier for the relation.
     * @type {number}
     * @memberof Relations
     */
    'id'?: number;
    /**
     * Collection that has the field that holds the foreign key.
     * @type {string}
     * @memberof Relations
     */
    'many_collection'?: string;
    /**
     * Foreign key. Field that holds the primary key of the related collection.
     * @type {string}
     * @memberof Relations
     */
    'many_field'?: string;
    /**
     * Collection on the _one_ side of the relationship.
     * @type {string}
     * @memberof Relations
     */
    'one_collection'?: string;
    /**
     * Alias column that serves as the _one_ side of the relationship.
     * @type {string}
     * @memberof Relations
     */
    'one_field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Relations
     */
    'one_collection_field'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Relations
     */
    'one_allowed_collections'?: Array<string> | null;
    /**
     * Field on the junction table that holds the many field of the related relation.
     * @type {string}
     * @memberof Relations
     */
    'junction_field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Relations
     */
    'sort_field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Relations
     */
    'one_deselect_action'?: string;
}
/**
 * 
 * @export
 * @interface Revisions
 */
export interface Revisions {
    /**
     * Unique identifier for the revision.
     * @type {number}
     * @memberof Revisions
     */
    'id'?: number;
    /**
     * 
     * @type {RevisionsActivity}
     * @memberof Revisions
     */
    'activity'?: RevisionsActivity;
    /**
     * 
     * @type {RevisionsCollection}
     * @memberof Revisions
     */
    'collection'?: RevisionsCollection;
    /**
     * Primary key of updated item.
     * @type {string}
     * @memberof Revisions
     */
    'item'?: string;
    /**
     * Copy of item state at time of update.
     * @type {object}
     * @memberof Revisions
     */
    'data'?: object | null;
    /**
     * Changes between the previous and the current revision.
     * @type {object}
     * @memberof Revisions
     */
    'delta'?: object;
    /**
     * If the current item was updated relationally, this is the id of the parent revision record
     * @type {number}
     * @memberof Revisions
     */
    'parent'?: number | null;
    /**
     * 
     * @type {RevisionsVersion}
     * @memberof Revisions
     */
    'version'?: RevisionsVersion;
}
/**
 * @type RevisionsActivity
 * Unique identifier for the activity record.
 * @export
 */
export type RevisionsActivity = Activity | number;

/**
 * @type RevisionsCollection
 * Collection of the updated item.
 * @export
 */
export type RevisionsCollection = Collections | string;

/**
 * @type RevisionsVersion
 * Associated version of this revision.
 * @export
 */
export type RevisionsVersion = Versions | string;

/**
 * 
 * @export
 * @interface Roles
 */
export interface Roles {
    /**
     * Unique identifier for the role.
     * @type {string}
     * @memberof Roles
     */
    'id'?: string;
    /**
     * Name of the role.
     * @type {string}
     * @memberof Roles
     */
    'name'?: string;
    /**
     * The role\'s icon.
     * @type {string}
     * @memberof Roles
     */
    'icon'?: string;
    /**
     * Description of the role.
     * @type {string}
     * @memberof Roles
     */
    'description'?: string | null;
    /**
     * 
     * @type {RolesParent}
     * @memberof Roles
     */
    'parent'?: RolesParent | null;
    /**
     * $t:field_options.directus_roles.children_note
     * @type {Array<RolesChildrenInner>}
     * @memberof Roles
     */
    'children'?: Array<RolesChildrenInner> | null;
    /**
     * 
     * @type {any}
     * @memberof Roles
     */
    'policies'?: any | null;
    /**
     * 
     * @type {Array<RolesUsersInner>}
     * @memberof Roles
     */
    'users'?: Array<RolesUsersInner> | null;
}
/**
 * @type RolesChildrenInner
 * @export
 */
export type RolesChildrenInner = Roles | string;

/**
 * @type RolesParent
 * $t:field_options.directus_roles.parent_note
 * @export
 */
export type RolesParent = Roles | string;

/**
 * @type RolesUsersInner
 * @export
 */
export type RolesUsersInner = Users | string;

/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    'directus'?: string;
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    'vendor'?: string;
    /**
     * 
     * @type {Array<Collections>}
     * @memberof Schema
     */
    'collections'?: Array<Collections>;
    /**
     * 
     * @type {Array<Fields>}
     * @memberof Schema
     */
    'fields'?: Array<Fields>;
    /**
     * 
     * @type {Array<Relations>}
     * @memberof Schema
     */
    'relations'?: Array<Relations>;
}
/**
 * 
 * @export
 * @interface SchemaApplyRequest
 */
export interface SchemaApplyRequest {
    /**
     * 
     * @type {Diff}
     * @memberof SchemaApplyRequest
     */
    'data'?: Diff;
}
/**
 * 
 * @export
 * @interface SchemaSnapshot200Response
 */
export interface SchemaSnapshot200Response {
    /**
     * 
     * @type {Schema}
     * @memberof SchemaSnapshot200Response
     */
    'data'?: Schema;
}
/**
 * 
 * @export
 * @interface ServerInfo200Response
 */
export interface ServerInfo200Response {
    /**
     * 
     * @type {object}
     * @memberof ServerInfo200Response
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface Settings
 */
export interface Settings {
    /**
     * Unique identifier for the setting.
     * @type {number}
     * @memberof Settings
     */
    'id'?: number;
    /**
     * The name of the project.
     * @type {string}
     * @memberof Settings
     */
    'project_name'?: string;
    /**
     * The url of the project.
     * @type {string}
     * @memberof Settings
     */
    'project_url'?: string | null;
    /**
     * The brand color of the project.
     * @type {string}
     * @memberof Settings
     */
    'project_color'?: string | null;
    /**
     * The logo of the project.
     * @type {string}
     * @memberof Settings
     */
    'project_logo'?: string | null;
    /**
     * The foreground of the project.
     * @type {string}
     * @memberof Settings
     */
    'public_foreground'?: string | null;
    /**
     * 
     * @type {SettingsPublicBackground}
     * @memberof Settings
     */
    'public_background'?: SettingsPublicBackground | null;
    /**
     * Note rendered on the public pages of the app.
     * @type {string}
     * @memberof Settings
     */
    'public_note'?: string | null;
    /**
     * Allowed authentication login attempts before the user\'s status is set to blocked.
     * @type {number}
     * @memberof Settings
     */
    'auth_login_attempts'?: number;
    /**
     * Authentication password policy.
     * @type {string}
     * @memberof Settings
     */
    'auth_password_policy'?: string | null;
    /**
     * What transformations are allowed in the assets endpoint.
     * @type {string}
     * @memberof Settings
     */
    'storage_asset_transform'?: SettingsStorageAssetTransformEnum | null;
    /**
     * Array of allowed
     * @type {Array<SettingsStorageAssetPresetsInner>}
     * @memberof Settings
     */
    'storage_asset_presets'?: Array<SettingsStorageAssetPresetsInner> | null;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'custom_css'?: string | null;
    /**
     * Default folder to place files
     * @type {string}
     * @memberof Settings
     */
    'storage_default_folder'?: string;
    /**
     * 
     * @type {any}
     * @memberof Settings
     */
    'basemaps'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'mapbox_key'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Settings
     */
    'module_bar'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'project_descriptor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'default_language'?: string;
    /**
     * 
     * @type {any}
     * @memberof Settings
     */
    'custom_aspect_ratios'?: any | null;
    /**
     * 
     * @type {SettingsPublicFavicon}
     * @memberof Settings
     */
    'public_favicon'?: SettingsPublicFavicon | null;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'default_appearance'?: string;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'default_theme_light'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Settings
     */
    'theme_light_overrides'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'default_theme_dark'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Settings
     */
    'theme_dark_overrides'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'report_error_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'report_bug_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'report_feature_url'?: string | null;
    /**
     * $t:fields.directus_settings.public_registration_note
     * @type {boolean}
     * @memberof Settings
     */
    'public_registration'?: boolean;
    /**
     * $t:fields.directus_settings.public_registration_verify_email_note
     * @type {boolean}
     * @memberof Settings
     */
    'public_registration_verify_email'?: boolean;
    /**
     * 
     * @type {SettingsPublicRegistrationRole}
     * @memberof Settings
     */
    'public_registration_role'?: SettingsPublicRegistrationRole | null;
    /**
     * $t:fields.directus_settings.public_registration_email_filter_note
     * @type {any}
     * @memberof Settings
     */
    'public_registration_email_filter'?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Settings
     */
    'visual_editor_urls'?: any | null;
}

export const SettingsStorageAssetTransformEnum = {
    All: 'all',
    None: 'none',
    Presets: 'presets'
} as const;

export type SettingsStorageAssetTransformEnum = typeof SettingsStorageAssetTransformEnum[keyof typeof SettingsStorageAssetTransformEnum];

/**
 * The background of the project.
 * @export
 * @interface SettingsPublicBackground
 */
export interface SettingsPublicBackground {
    /**
     * 
     * @type {string}
     * @memberof SettingsPublicBackground
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingsPublicBackground
     */
    'type'?: string;
}
/**
 * @type SettingsPublicFavicon
 * $t:field_options.directus_settings.project_favicon_note
 * @export
 */
export type SettingsPublicFavicon = Files | string;

/**
 * @type SettingsPublicRegistrationRole
 * $t:fields.directus_settings.public_registration_role_note
 * @export
 */
export type SettingsPublicRegistrationRole = Roles | string;

/**
 * 
 * @export
 * @interface SettingsStorageAssetPresetsInner
 */
export interface SettingsStorageAssetPresetsInner {
    /**
     * Key for the asset. Used in the assets endpoint.
     * @type {string}
     * @memberof SettingsStorageAssetPresetsInner
     */
    'key'?: string;
    /**
     * Whether to crop the thumbnail to match the size, or maintain the aspect ratio.
     * @type {string}
     * @memberof SettingsStorageAssetPresetsInner
     */
    'fit'?: SettingsStorageAssetPresetsInnerFitEnum;
    /**
     * Width of the thumbnail.
     * @type {number}
     * @memberof SettingsStorageAssetPresetsInner
     */
    'width'?: number;
    /**
     * Height of the thumbnail.
     * @type {number}
     * @memberof SettingsStorageAssetPresetsInner
     */
    'height'?: number;
    /**
     * No image upscale
     * @type {boolean}
     * @memberof SettingsStorageAssetPresetsInner
     */
    'withoutEnlargement'?: boolean;
    /**
     * Quality of the compression used.
     * @type {number}
     * @memberof SettingsStorageAssetPresetsInner
     */
    'quality'?: number;
    /**
     * Reformat output image
     * @type {string}
     * @memberof SettingsStorageAssetPresetsInner
     */
    'format'?: SettingsStorageAssetPresetsInnerFormatEnum;
    /**
     * Additional transformations to apply
     * @type {Array<SettingsStorageAssetPresetsInnerTransformsInner>}
     * @memberof SettingsStorageAssetPresetsInner
     */
    'transforms'?: Array<SettingsStorageAssetPresetsInnerTransformsInner> | null;
}

export const SettingsStorageAssetPresetsInnerFitEnum = {
    Cover: 'cover',
    Contain: 'contain',
    Inside: 'inside',
    Outside: 'outside'
} as const;

export type SettingsStorageAssetPresetsInnerFitEnum = typeof SettingsStorageAssetPresetsInnerFitEnum[keyof typeof SettingsStorageAssetPresetsInnerFitEnum];
export const SettingsStorageAssetPresetsInnerFormatEnum = {
    Empty: '',
    Jpeg: 'jpeg',
    Png: 'png',
    Webp: 'webp',
    Tiff: 'tiff',
    Avif: 'avif'
} as const;

export type SettingsStorageAssetPresetsInnerFormatEnum = typeof SettingsStorageAssetPresetsInnerFormatEnum[keyof typeof SettingsStorageAssetPresetsInnerFormatEnum];

/**
 * 
 * @export
 * @interface SettingsStorageAssetPresetsInnerTransformsInner
 */
export interface SettingsStorageAssetPresetsInnerTransformsInner {
    /**
     * The Sharp method name
     * @type {string}
     * @memberof SettingsStorageAssetPresetsInnerTransformsInner
     */
    'method'?: string;
    /**
     * A list of arguments to pass to the Sharp method
     * @type {Array<SettingsStorageAssetPresetsInnerTransformsInnerArgumentsInner>}
     * @memberof SettingsStorageAssetPresetsInnerTransformsInner
     */
    'arguments'?: Array<SettingsStorageAssetPresetsInnerTransformsInnerArgumentsInner> | null;
}
/**
 * 
 * @export
 * @interface SettingsStorageAssetPresetsInnerTransformsInnerArgumentsInner
 */
export interface SettingsStorageAssetPresetsInnerTransformsInnerArgumentsInner {
    /**
     * A JSON representation of the argument value
     * @type {string}
     * @memberof SettingsStorageAssetPresetsInnerTransformsInnerArgumentsInner
     */
    'argument'?: string;
}
/**
 * 
 * @export
 * @interface SortRequest
 */
export interface SortRequest {
    /**
     * Primary key of item to move
     * @type {number}
     * @memberof SortRequest
     */
    'item'?: number;
    /**
     * Primary key of item where to move the current item to
     * @type {number}
     * @memberof SortRequest
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface UpdateCollectionRequest
 */
export interface UpdateCollectionRequest {
    /**
     * 
     * @type {UpdateCollectionRequestMeta}
     * @memberof UpdateCollectionRequest
     */
    'meta'?: UpdateCollectionRequestMeta;
}
/**
 * Metadata of the collection.
 * @export
 * @interface UpdateCollectionRequestMeta
 */
export interface UpdateCollectionRequestMeta {
    /**
     * Name of a Google Material Design Icon that\'s assigned to this collection.
     * @type {string}
     * @memberof UpdateCollectionRequestMeta
     */
    'icon'?: string | null;
    /**
     * Choose the color for the icon assigned to this collection.
     * @type {string}
     * @memberof UpdateCollectionRequestMeta
     */
    'color'?: string | null;
    /**
     * A note describing the collection.
     * @type {string}
     * @memberof UpdateCollectionRequestMeta
     */
    'note'?: string | null;
    /**
     * Text representation of how items from this collection are shown across the system.
     * @type {string}
     * @memberof UpdateCollectionRequestMeta
     */
    'display_template'?: string | null;
    /**
     * Whether or not the collection is hidden from the navigation in the admin app.
     * @type {boolean}
     * @memberof UpdateCollectionRequestMeta
     */
    'hidden'?: boolean;
    /**
     * Whether or not the collection is treated as a single object.
     * @type {boolean}
     * @memberof UpdateCollectionRequestMeta
     */
    'singleton'?: boolean;
    /**
     * Key value pairs of how to show this collection\'s name in different languages in the admin app.
     * @type {string}
     * @memberof UpdateCollectionRequestMeta
     */
    'translation'?: string | null;
    /**
     * Whether or not Content Versioning is enabled for this collection.
     * @type {boolean}
     * @memberof UpdateCollectionRequestMeta
     */
    'versioning'?: boolean;
    /**
     * What field holds the archive value.
     * @type {string}
     * @memberof UpdateCollectionRequestMeta
     */
    'archive_field'?: string | null;
    /**
     * What value to use for \"archived\" items.
     * @type {string}
     * @memberof UpdateCollectionRequestMeta
     */
    'archive_app_filter'?: string | null;
    /**
     * What value to use to \"unarchive\" items.
     * @type {string}
     * @memberof UpdateCollectionRequestMeta
     */
    'archive_value'?: string | null;
    /**
     * Whether or not to show the \"archived\" filter.
     * @type {string}
     * @memberof UpdateCollectionRequestMeta
     */
    'unarchive_value'?: string | null;
    /**
     * The sort field in the collection.
     * @type {string}
     * @memberof UpdateCollectionRequestMeta
     */
    'sort_field'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateCommentRequest
 */
export interface UpdateCommentRequest {
    /**
     * Which collection this comment is for.
     * @type {string}
     * @memberof UpdateCommentRequest
     */
    'collection': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCommentRequest
     */
    'item'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCommentRequest
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCommentsRequest
 */
export interface UpdateCommentsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCommentsRequest
     */
    'keys'?: Array<string>;
    /**
     * 
     * @type {UpdateCommentsRequestData}
     * @memberof UpdateCommentsRequest
     */
    'data'?: UpdateCommentsRequestData;
}
/**
 * 
 * @export
 * @interface UpdateCommentsRequestData
 */
export interface UpdateCommentsRequestData {
    /**
     * Which collection this collection comment is for.
     * @type {string}
     * @memberof UpdateCommentsRequestData
     */
    'collection': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCommentsRequestData
     */
    'item'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCommentsRequestData
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface UpdateContentVersionsRequest
 */
export interface UpdateContentVersionsRequest {
    /**
     * 
     * @type {Versions}
     * @memberof UpdateContentVersionsRequest
     */
    'data'?: Versions;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateContentVersionsRequest
     */
    'keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateExtensions200Response
 */
export interface UpdateExtensions200Response {
    /**
     * 
     * @type {Extensions}
     * @memberof UpdateExtensions200Response
     */
    'data'?: Extensions;
}
/**
 * 
 * @export
 * @interface UpdateExtensionsRequest
 */
export interface UpdateExtensionsRequest {
    /**
     * 
     * @type {UpdateExtensionsRequestMeta}
     * @memberof UpdateExtensionsRequest
     */
    'meta'?: UpdateExtensionsRequestMeta;
}
/**
 * Directus metadata for the extension. Where the configuration for the extension in the current project is stored.
 * @export
 * @interface UpdateExtensionsRequestMeta
 */
export interface UpdateExtensionsRequestMeta {
    /**
     * Whether or not the extension is enabled.
     * @type {boolean}
     * @memberof UpdateExtensionsRequestMeta
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateFieldRequest
 */
export interface UpdateFieldRequest {
    /**
     * Unique name of the field. Field name is unique within the collection.
     * @type {string}
     * @memberof UpdateFieldRequest
     */
    'field'?: string;
    /**
     * Directus specific data type. Used to cast values in the API.
     * @type {string}
     * @memberof UpdateFieldRequest
     */
    'type'?: string;
    /**
     * 
     * @type {CreateFieldRequestSchema}
     * @memberof UpdateFieldRequest
     */
    'schema'?: CreateFieldRequestSchema;
    /**
     * 
     * @type {CreateFieldRequestMeta}
     * @memberof UpdateFieldRequest
     */
    'meta'?: CreateFieldRequestMeta | null;
}
/**
 * 
 * @export
 * @interface UpdateFileRequest
 */
export interface UpdateFileRequest {
    /**
     * Title for the file. Is extracted from the filename on upload, but can be edited by the user.
     * @type {string}
     * @memberof UpdateFileRequest
     */
    'title'?: string;
    /**
     * Preferred filename when file is downloaded.
     * @type {string}
     * @memberof UpdateFileRequest
     */
    'filename_download'?: string;
    /**
     * Description for the file.
     * @type {string}
     * @memberof UpdateFileRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {UpdateFileRequestFolder}
     * @memberof UpdateFileRequest
     */
    'folder'?: UpdateFileRequestFolder | null;
    /**
     * Tags for the file. Is automatically populated based on Exif data for images.
     * @type {Array<string>}
     * @memberof UpdateFileRequest
     */
    'tags'?: Array<string> | null;
    /**
     * File contents.
     * @type {any}
     * @memberof UpdateFileRequest
     */
    'file': any;
}
/**
 * 
 * @export
 * @interface UpdateFileRequest1
 */
export interface UpdateFileRequest1 {
    /**
     * Title for the file. Is extracted from the filename on upload, but can be edited by the user.
     * @type {string}
     * @memberof UpdateFileRequest1
     */
    'title'?: string;
    /**
     * Preferred filename when file is downloaded.
     * @type {string}
     * @memberof UpdateFileRequest1
     */
    'filename_download'?: string;
    /**
     * Description for the file.
     * @type {string}
     * @memberof UpdateFileRequest1
     */
    'description'?: string | null;
    /**
     * 
     * @type {UpdateFileRequestFolder}
     * @memberof UpdateFileRequest1
     */
    'folder'?: UpdateFileRequestFolder | null;
    /**
     * Tags for the file. Is automatically populated based on Exif data for images.
     * @type {Array<string>}
     * @memberof UpdateFileRequest1
     */
    'tags'?: Array<string> | null;
}
/**
 * @type UpdateFileRequestFolder
 * Virtual folder where this file resides in.
 * @export
 */
export type UpdateFileRequestFolder = Folders | string;

/**
 * 
 * @export
 * @interface UpdateFilesRequest
 */
export interface UpdateFilesRequest {
    /**
     * 
     * @type {CreateFileRequest}
     * @memberof UpdateFilesRequest
     */
    'data'?: CreateFileRequest;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateFilesRequest
     */
    'keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateFlowsRequest
 */
export interface UpdateFlowsRequest {
    /**
     * 
     * @type {Flows}
     * @memberof UpdateFlowsRequest
     */
    'data'?: Flows;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateFlowsRequest
     */
    'keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateFolderRequest
 */
export interface UpdateFolderRequest {
    /**
     * Name of the folder. Can\'t be null or empty.
     * @type {string}
     * @memberof UpdateFolderRequest
     */
    'name'?: string;
    /**
     * Unique identifier of the parent folder. This allows for nested folders.
     * @type {number}
     * @memberof UpdateFolderRequest
     */
    'parent'?: number;
}
/**
 * 
 * @export
 * @interface UpdateFoldersRequest
 */
export interface UpdateFoldersRequest {
    /**
     * 
     * @type {CreateFolderRequest}
     * @memberof UpdateFoldersRequest
     */
    'data'?: CreateFolderRequest;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateFoldersRequest
     */
    'keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateItemsArticles200Response
 */
export interface UpdateItemsArticles200Response {
    /**
     * 
     * @type {Array<ItemsArticles>}
     * @memberof UpdateItemsArticles200Response
     */
    'data'?: Array<ItemsArticles>;
}
/**
 * 
 * @export
 * @interface UpdateItemsUsers200Response
 */
export interface UpdateItemsUsers200Response {
    /**
     * 
     * @type {Array<ItemsUsers>}
     * @memberof UpdateItemsUsers200Response
     */
    'data'?: Array<ItemsUsers>;
}
/**
 * 
 * @export
 * @interface UpdateLastUsedPageMeRequest
 */
export interface UpdateLastUsedPageMeRequest {
    /**
     * Path of the page you used last.
     * @type {string}
     * @memberof UpdateLastUsedPageMeRequest
     */
    'last_page'?: string;
}
/**
 * 
 * @export
 * @interface UpdateOperationsRequest
 */
export interface UpdateOperationsRequest {
    /**
     * 
     * @type {Operations}
     * @memberof UpdateOperationsRequest
     */
    'data'?: Operations;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateOperationsRequest
     */
    'keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdatePermissionRequest
 */
export interface UpdatePermissionRequest {
    /**
     * What collection this permission applies to.
     * @type {object}
     * @memberof UpdatePermissionRequest
     */
    'collection'?: object;
    /**
     * If the user can post comments. `full`.
     * @type {string}
     * @memberof UpdatePermissionRequest
     */
    'comment'?: UpdatePermissionRequestCommentEnum;
    /**
     * If the user can create items.
     * @type {string}
     * @memberof UpdatePermissionRequest
     */
    'create'?: UpdatePermissionRequestCreateEnum;
    /**
     * If the user can update items.
     * @type {string}
     * @memberof UpdatePermissionRequest
     */
    'delete'?: UpdatePermissionRequestDeleteEnum;
    /**
     * If the user is required to leave a comment explaining what was changed.
     * @type {string}
     * @memberof UpdatePermissionRequest
     */
    'explain'?: UpdatePermissionRequestExplainEnum;
    /**
     * If the user can read items.
     * @type {string}
     * @memberof UpdatePermissionRequest
     */
    'read'?: UpdatePermissionRequestReadEnum;
    /**
     * Explicitly denies read access for specific fields.
     * @type {object}
     * @memberof UpdatePermissionRequest
     */
    'read_field_blacklist'?: object;
    /**
     * Unique identifier of the role this permission applies to.
     * @type {object}
     * @memberof UpdatePermissionRequest
     */
    'role'?: object;
    /**
     * What status this permission applies to.
     * @type {object}
     * @memberof UpdatePermissionRequest
     */
    'status'?: object;
    /**
     * Explicitly denies specific statuses to be used.
     * @type {object}
     * @memberof UpdatePermissionRequest
     */
    'status_blacklist'?: object;
    /**
     * If the user can update items.
     * @type {string}
     * @memberof UpdatePermissionRequest
     */
    'update'?: UpdatePermissionRequestUpdateEnum;
    /**
     * Explicitly denies write access for specific fields.
     * @type {object}
     * @memberof UpdatePermissionRequest
     */
    'write_field_blacklist'?: object;
}

export const UpdatePermissionRequestCommentEnum = {
    None: 'none',
    Create: 'create',
    Update: 'update'
} as const;

export type UpdatePermissionRequestCommentEnum = typeof UpdatePermissionRequestCommentEnum[keyof typeof UpdatePermissionRequestCommentEnum];
export const UpdatePermissionRequestCreateEnum = {
    None: 'none',
    Full: 'full'
} as const;

export type UpdatePermissionRequestCreateEnum = typeof UpdatePermissionRequestCreateEnum[keyof typeof UpdatePermissionRequestCreateEnum];
export const UpdatePermissionRequestDeleteEnum = {
    None: 'none',
    Mine: 'mine',
    Role: 'role',
    Full: 'full'
} as const;

export type UpdatePermissionRequestDeleteEnum = typeof UpdatePermissionRequestDeleteEnum[keyof typeof UpdatePermissionRequestDeleteEnum];
export const UpdatePermissionRequestExplainEnum = {
    None: 'none',
    Create: 'create',
    Update: 'update',
    Always: 'always'
} as const;

export type UpdatePermissionRequestExplainEnum = typeof UpdatePermissionRequestExplainEnum[keyof typeof UpdatePermissionRequestExplainEnum];
export const UpdatePermissionRequestReadEnum = {
    None: 'none',
    Mine: 'mine',
    Role: 'role',
    Full: 'full'
} as const;

export type UpdatePermissionRequestReadEnum = typeof UpdatePermissionRequestReadEnum[keyof typeof UpdatePermissionRequestReadEnum];
export const UpdatePermissionRequestUpdateEnum = {
    None: 'none',
    Mine: 'mine',
    Role: 'role',
    Full: 'full'
} as const;

export type UpdatePermissionRequestUpdateEnum = typeof UpdatePermissionRequestUpdateEnum[keyof typeof UpdatePermissionRequestUpdateEnum];

/**
 * 
 * @export
 * @interface UpdatePermissionsRequest
 */
export interface UpdatePermissionsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePermissionsRequest
     */
    'keys'?: Array<string>;
    /**
     * 
     * @type {CreatePermissionRequest}
     * @memberof UpdatePermissionsRequest
     */
    'data'?: CreatePermissionRequest;
}
/**
 * 
 * @export
 * @interface UpdatePresetRequest
 */
export interface UpdatePresetRequest {
    /**
     * What collection this collection preset is used for.
     * @type {string}
     * @memberof UpdatePresetRequest
     */
    'collection': string;
    /**
     * Name for the bookmark. If this is set, the collection preset will be considered to be a bookmark.
     * @type {string}
     * @memberof UpdatePresetRequest
     */
    'title'?: string;
    /**
     * The unique identifier of a role in the platform. If user is null, this will be used to apply the collection preset or bookmark for all users in the role.
     * @type {number}
     * @memberof UpdatePresetRequest
     */
    'role'?: number;
    /**
     * What the user searched for in search/filter in the header bar.
     * @type {string}
     * @memberof UpdatePresetRequest
     */
    'search_query'?: string;
    /**
     * 
     * @type {Array<UpdatePresetRequestFiltersInner>}
     * @memberof UpdatePresetRequest
     */
    'filters'?: Array<UpdatePresetRequestFiltersInner>;
    /**
     * Name of the view type that is used. Defaults to tabular.
     * @type {string}
     * @memberof UpdatePresetRequest
     */
    'view_type'?: string;
    /**
     * View query that\'s saved per view type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters.
     * @type {string}
     * @memberof UpdatePresetRequest
     */
    'view_query'?: string;
    /**
     * Options of the views. The properties in here are controlled by the layout.
     * @type {string}
     * @memberof UpdatePresetRequest
     */
    'view_options'?: string;
    /**
     * Key value pair of language-translation. Can be used to translate the bookmark title in multiple languages.
     * @type {object}
     * @memberof UpdatePresetRequest
     */
    'translation'?: object;
}
/**
 * 
 * @export
 * @interface UpdatePresetRequestFiltersInner
 */
export interface UpdatePresetRequestFiltersInner {
    /**
     * 
     * @type {string}
     * @memberof UpdatePresetRequestFiltersInner
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePresetRequestFiltersInner
     */
    'operator'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdatePresetRequestFiltersInner
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface UpdatePresetsRequest
 */
export interface UpdatePresetsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePresetsRequest
     */
    'keys'?: Array<string>;
    /**
     * 
     * @type {CreatePresetRequest}
     * @memberof UpdatePresetsRequest
     */
    'data'?: CreatePresetRequest;
}
/**
 * 
 * @export
 * @interface UpdateRelationRequest
 */
export interface UpdateRelationRequest {
    /**
     * Collection that has the field that holds the foreign key.
     * @type {string}
     * @memberof UpdateRelationRequest
     */
    'collection_many'?: string;
    /**
     * Collection on the _one_ side of the relationship.
     * @type {string}
     * @memberof UpdateRelationRequest
     */
    'collection_one'?: string;
    /**
     * Foreign key. Field that holds the primary key of the related collection.
     * @type {string}
     * @memberof UpdateRelationRequest
     */
    'field_many'?: string;
    /**
     * Alias column that serves as the _one_ side of the relationship.
     * @type {string}
     * @memberof UpdateRelationRequest
     */
    'field_one'?: string;
    /**
     * Field on the junction table that holds the primary key of the related collection.
     * @type {string}
     * @memberof UpdateRelationRequest
     */
    'junction_field'?: string;
}
/**
 * 
 * @export
 * @interface UpdateRoleRequest
 */
export interface UpdateRoleRequest {
    /**
     * Description of the role.
     * @type {string}
     * @memberof UpdateRoleRequest
     */
    'description'?: string;
    /**
     * Whether or not this role enforces the use of 2FA.
     * @type {boolean}
     * @memberof UpdateRoleRequest
     */
    'enforce_tfa'?: boolean;
    /**
     * ID used with external services in SCIM.
     * @type {string}
     * @memberof UpdateRoleRequest
     */
    'external_id'?: string;
    /**
     * Array of IP addresses that are allowed to connect to the API as a user of this role.
     * @type {Array<string>}
     * @memberof UpdateRoleRequest
     */
    'ip_access'?: Array<string>;
    /**
     * Custom override for the admin app module bar navigation.
     * @type {string}
     * @memberof UpdateRoleRequest
     */
    'module_listing'?: string;
    /**
     * Name of the role.
     * @type {string}
     * @memberof UpdateRoleRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateRolesRequest
 */
export interface UpdateRolesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRolesRequest
     */
    'keys'?: Array<string>;
    /**
     * 
     * @type {CreateRoleRequest}
     * @memberof UpdateRolesRequest
     */
    'data'?: CreateRoleRequest;
}
/**
 * 
 * @export
 * @interface UpdateUsersRequest
 */
export interface UpdateUsersRequest {
    /**
     * 
     * @type {Users}
     * @memberof UpdateUsersRequest
     */
    'data'?: Users;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUsersRequest
     */
    'keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateWebhooks200Response
 */
export interface UpdateWebhooks200Response {
    /**
     * 
     * @type {Array<Webhooks>}
     * @memberof UpdateWebhooks200Response
     */
    'data'?: Array<Webhooks>;
    /**
     * 
     * @type {XMetadata}
     * @memberof UpdateWebhooks200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface UpdateWebhooksRequest
 */
export interface UpdateWebhooksRequest {
    /**
     * 
     * @type {CreateWebhookRequest}
     * @memberof UpdateWebhooksRequest
     */
    'data'?: CreateWebhookRequest;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateWebhooksRequest
     */
    'keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * Unique identifier for the user.
     * @type {string}
     * @memberof Users
     */
    'id'?: string;
    /**
     * First name of the user.
     * @type {string}
     * @memberof Users
     */
    'first_name'?: string;
    /**
     * Last name of the user.
     * @type {string}
     * @memberof Users
     */
    'last_name'?: string;
    /**
     * Unique email address for the user.
     * @type {string}
     * @memberof Users
     */
    'email'?: string;
    /**
     * Password of the user.
     * @type {string}
     * @memberof Users
     */
    'password'?: string;
    /**
     * The user\'s location.
     * @type {string}
     * @memberof Users
     */
    'location'?: string | null;
    /**
     * The user\'s title.
     * @type {string}
     * @memberof Users
     */
    'title'?: string | null;
    /**
     * The user\'s description.
     * @type {string}
     * @memberof Users
     */
    'description'?: string | null;
    /**
     * The user\'s tags.
     * @type {Array<string>}
     * @memberof Users
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {UsersAvatar}
     * @memberof Users
     */
    'avatar'?: UsersAvatar | null;
    /**
     * The user\'s language used in Directus.
     * @type {string}
     * @memberof Users
     */
    'language'?: string;
    /**
     * The 2FA secret string that\'s used to generate one time passwords.
     * @type {string}
     * @memberof Users
     */
    'tfa_secret'?: string | null;
    /**
     * Status of the user.
     * @type {string}
     * @memberof Users
     */
    'status'?: UsersStatusEnum;
    /**
     * 
     * @type {UsersRole}
     * @memberof Users
     */
    'role'?: UsersRole;
    /**
     * Static token for the user.
     * @type {string}
     * @memberof Users
     */
    'token'?: string | null;
    /**
     * When this user used the API last.
     * @type {string}
     * @memberof Users
     */
    'last_access'?: string | null;
    /**
     * Last page that the user was on.
     * @type {string}
     * @memberof Users
     */
    'last_page'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'external_identifier'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Users
     */
    'auth_data'?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof Users
     */
    'email_notifications'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'appearance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'theme_dark'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'theme_light'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Users
     */
    'theme_light_overrides'?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Users
     */
    'theme_dark_overrides'?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Users
     */
    'policies'?: any | null;
}

export const UsersStatusEnum = {
    Active: 'active',
    Invited: 'invited',
    Draft: 'draft',
    Suspended: 'suspended',
    Deleted: 'deleted'
} as const;

export type UsersStatusEnum = typeof UsersStatusEnum[keyof typeof UsersStatusEnum];

/**
 * @type UsersAvatar
 * The user\'s avatar.
 * @export
 */
export type UsersAvatar = Files | string;

/**
 * @type UsersRole
 * Unique identifier of the role of this user.
 * @export
 */
export type UsersRole = Roles | string;

/**
 * 
 * @export
 * @interface Versions
 */
export interface Versions {
    /**
     * Primary key of the Content Version.
     * @type {string}
     * @memberof Versions
     */
    'id'?: string;
    /**
     * Key of the Content Version, used as the value for the \"version\" query parameter.
     * @type {string}
     * @memberof Versions
     */
    'key'?: string;
    /**
     * Descriptive name of the Content Version.
     * @type {string}
     * @memberof Versions
     */
    'name'?: string;
    /**
     * 
     * @type {VersionsCollection}
     * @memberof Versions
     */
    'collection'?: VersionsCollection;
    /**
     * The item the Content Version is created on.
     * @type {string}
     * @memberof Versions
     */
    'item'?: string;
    /**
     * 
     * @type {string}
     * @memberof Versions
     */
    'hash'?: string | null;
    /**
     * When the Content Version was created.
     * @type {string}
     * @memberof Versions
     */
    'date_created'?: string | null;
    /**
     * When the Content Version was last updated.
     * @type {string}
     * @memberof Versions
     */
    'date_updated'?: string | null;
    /**
     * 
     * @type {VersionsUserCreated}
     * @memberof Versions
     */
    'user_created'?: VersionsUserCreated;
    /**
     * 
     * @type {VersionsUserUpdated}
     * @memberof Versions
     */
    'user_updated'?: VersionsUserUpdated;
    /**
     * The current changes compared to the main version of the item.
     * @type {object}
     * @memberof Versions
     */
    'delta'?: object;
}
/**
 * @type VersionsCollection
 * Name of the collection the Content Version is created on.
 * @export
 */
export type VersionsCollection = Collections | string;

/**
 * @type VersionsUserCreated
 * User that created the Content Version.
 * @export
 */
export type VersionsUserCreated = Users | string;

/**
 * @type VersionsUserUpdated
 * User that last updated the Content Version.
 * @export
 */
export type VersionsUserUpdated = Users | string;

/**
 * 
 * @export
 * @interface Webhooks
 */
export interface Webhooks {
    /**
     * The index of the webhook.
     * @type {number}
     * @memberof Webhooks
     */
    'id'?: number;
    /**
     * The name of the webhook.
     * @type {string}
     * @memberof Webhooks
     */
    'name'?: string;
    /**
     * Method used in the webhook.
     * @type {string}
     * @memberof Webhooks
     */
    'method'?: string;
    /**
     * The url of the webhook.
     * @type {string}
     * @memberof Webhooks
     */
    'url'?: string | null;
    /**
     * The status of the webhook.
     * @type {string}
     * @memberof Webhooks
     */
    'status'?: string;
    /**
     * If yes, send the content of what was done
     * @type {boolean}
     * @memberof Webhooks
     */
    'data'?: boolean;
    /**
     * The actions that triggers this webhook.
     * @type {Array<string>}
     * @memberof Webhooks
     */
    'actions'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Webhooks
     */
    'collections'?: Array<string>;
    /**
     * 
     * @type {any}
     * @memberof Webhooks
     */
    'headers'?: any | null;
    /**
     * 
     * @type {boolean}
     * @memberof Webhooks
     */
    'was_active_before_deprecation'?: boolean;
    /**
     * 
     * @type {WebhooksMigratedFlow}
     * @memberof Webhooks
     */
    'migrated_flow'?: WebhooksMigratedFlow | null;
}
/**
 * @type WebhooksMigratedFlow
 * @export
 */
export type WebhooksMigratedFlow = Flows | string;

/**
 * 
 * @export
 * @interface XMetadata
 */
export interface XMetadata {
    /**
     * Returns the total item count of the collection you\'re querying.
     * @type {number}
     * @memberof XMetadata
     */
    'total_count'?: number;
    /**
     * Returns the item count of the collection you\'re querying, taking the current filter/search parameters into account.
     * @type {number}
     * @memberof XMetadata
     */
    'filter_count'?: number;
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of activity actions.
         * @summary List Activity Actions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information.
         * @summary Retrieve an Activity Action
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (id: number, fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getActivity', 'id', id)
            const localVarPath = `/activity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of activity actions.
         * @summary List Activity Actions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivities(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetActivities200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(fields, limit, meta, offset, sort, filter, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.getActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information.
         * @summary Retrieve an Activity Action
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetActivity200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(id, fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityApi.getActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         * Returns a list of activity actions.
         * @summary List Activity Actions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetActivities200Response> {
            return localVarFp.getActivities(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information.
         * @summary Retrieve an Activity Action
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetActivity200Response> {
            return localVarFp.getActivity(id, fields, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * Returns a list of activity actions.
     * @summary List Activity Actions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public getActivities(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getActivities(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information.
     * @summary Retrieve an Activity Action
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public getActivity(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return ActivityApiFp(this.configuration).getActivity(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Image typed files can be dynamically resized and transformed to fit any need.
         * @summary Get an Asset
         * @param {string} id The id of the file.
         * @param {string} [key] The key of the asset size configured in settings.
         * @param {string} [transforms] A JSON array of image transformations
         * @param {boolean} [download] Download the asset to your computer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (id: string, key?: string, transforms?: string, download?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAsset', 'id', id)
            const localVarPath = `/assets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (transforms !== undefined) {
                localVarQueryParameter['transforms'] = transforms;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Image typed files can be dynamically resized and transformed to fit any need.
         * @summary Get an Asset
         * @param {string} id The id of the file.
         * @param {string} [key] The key of the asset size configured in settings.
         * @param {string} [transforms] A JSON array of image transformations
         * @param {boolean} [download] Download the asset to your computer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(id: string, key?: string, transforms?: string, download?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(id, key, transforms, download, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsApi.getAsset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * Image typed files can be dynamically resized and transformed to fit any need.
         * @summary Get an Asset
         * @param {string} id The id of the file.
         * @param {string} [key] The key of the asset size configured in settings.
         * @param {string} [transforms] A JSON array of image transformations
         * @param {boolean} [download] Download the asset to your computer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(id: string, key?: string, transforms?: string, download?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getAsset(id, key, transforms, download, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * Image typed files can be dynamically resized and transformed to fit any need.
     * @summary Get an Asset
     * @param {string} id The id of the file.
     * @param {string} [key] The key of the asset size configured in settings.
     * @param {string} [transforms] A JSON array of image transformations
     * @param {boolean} [download] Download the asset to your computer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAsset(id: string, key?: string, transforms?: string, download?: boolean, options?: RawAxiosRequestConfig) {
        return AssetsApiFp(this.configuration).getAsset(id, key, transforms, download, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a Temporary Access Token
         * @summary Retrieve a Temporary Access Token
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log Out
         * @summary Log Out
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (logoutRequest?: LogoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List configured OAuth providers.
         * @summary List OAuth Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start OAuth flow using the specified provider
         * @summary Authenticated using an OAuth provider
         * @param {string} provider Key of the activated OAuth provider.
         * @param {string} [redirect] Where to redirect on successful login.&lt;br/&gt;If set the authentication details are set inside cookies otherwise a JSON is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProvider: async (provider: string, redirect?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('oauthProvider', 'provider', provider)
            const localVarPath = `/auth/oauth/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a reset password email to be send.
         * @summary Request a Password Reset
         * @param {PasswordRequestRequest} [passwordRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordRequest: async (passwordRequestRequest?: PasswordRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/password/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
         * @summary Reset a Password
         * @param {PasswordResetRequest} [passwordResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordReset: async (passwordResetRequest?: PasswordResetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/password/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh a Temporary Access Token.
         * @summary Refresh Token
         * @param {RefreshRequest} [refreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (refreshRequest?: RefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a Temporary Access Token
         * @summary Retrieve a Temporary Access Token
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Login200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Log Out
         * @summary Log Out
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(logoutRequest?: LogoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(logoutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List configured OAuth providers.
         * @summary List OAuth Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Oauth200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.oauth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start OAuth flow using the specified provider
         * @summary Authenticated using an OAuth provider
         * @param {string} provider Key of the activated OAuth provider.
         * @param {string} [redirect] Where to redirect on successful login.&lt;br/&gt;If set the authentication details are set inside cookies otherwise a JSON is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProvider(provider: string, redirect?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthProvider200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProvider(provider, redirect, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.oauthProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request a reset password email to be send.
         * @summary Request a Password Reset
         * @param {PasswordRequestRequest} [passwordRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordRequest(passwordRequestRequest?: PasswordRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordRequest(passwordRequestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.passwordRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
         * @summary Reset a Password
         * @param {PasswordResetRequest} [passwordResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordReset(passwordResetRequest?: PasswordResetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordReset(passwordResetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.passwordReset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh a Temporary Access Token.
         * @summary Refresh Token
         * @param {RefreshRequest} [refreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(refreshRequest?: RefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refresh200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(refreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.refresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Retrieve a Temporary Access Token
         * @summary Retrieve a Temporary Access Token
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<Login200Response> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Log Out
         * @summary Log Out
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(logoutRequest?: LogoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(logoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List configured OAuth providers.
         * @summary List OAuth Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth(options?: RawAxiosRequestConfig): AxiosPromise<Oauth200Response> {
            return localVarFp.oauth(options).then((request) => request(axios, basePath));
        },
        /**
         * Start OAuth flow using the specified provider
         * @summary Authenticated using an OAuth provider
         * @param {string} provider Key of the activated OAuth provider.
         * @param {string} [redirect] Where to redirect on successful login.&lt;br/&gt;If set the authentication details are set inside cookies otherwise a JSON is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProvider(provider: string, redirect?: string, options?: RawAxiosRequestConfig): AxiosPromise<OauthProvider200Response> {
            return localVarFp.oauthProvider(provider, redirect, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a reset password email to be send.
         * @summary Request a Password Reset
         * @param {PasswordRequestRequest} [passwordRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordRequest(passwordRequestRequest?: PasswordRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.passwordRequest(passwordRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
         * @summary Reset a Password
         * @param {PasswordResetRequest} [passwordResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordReset(passwordResetRequest?: PasswordResetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.passwordReset(passwordResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh a Temporary Access Token.
         * @summary Refresh Token
         * @param {RefreshRequest} [refreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(refreshRequest?: RefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<Refresh200Response> {
            return localVarFp.refresh(refreshRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Retrieve a Temporary Access Token
     * @summary Retrieve a Temporary Access Token
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log Out
     * @summary Log Out
     * @param {LogoutRequest} [logoutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(logoutRequest?: LogoutRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(logoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List configured OAuth providers.
     * @summary List OAuth Providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public oauth(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).oauth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start OAuth flow using the specified provider
     * @summary Authenticated using an OAuth provider
     * @param {string} provider Key of the activated OAuth provider.
     * @param {string} [redirect] Where to redirect on successful login.&lt;br/&gt;If set the authentication details are set inside cookies otherwise a JSON is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public oauthProvider(provider: string, redirect?: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).oauthProvider(provider, redirect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request a reset password email to be send.
     * @summary Request a Password Reset
     * @param {PasswordRequestRequest} [passwordRequestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public passwordRequest(passwordRequestRequest?: PasswordRequestRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).passwordRequest(passwordRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
     * @summary Reset a Password
     * @param {PasswordResetRequest} [passwordResetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public passwordReset(passwordResetRequest?: PasswordResetRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).passwordReset(passwordResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh a Temporary Access Token.
     * @summary Refresh Token
     * @param {RefreshRequest} [refreshRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refresh(refreshRequest?: RefreshRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refresh(refreshRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new collection in Directus.
         * @summary Create a Collection
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (meta?: string, createCollectionRequest?: CreateCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution.
         * @summary Delete a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCollection', 'id', id)
            const localVarPath = `/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a single collection.
         * @summary Retrieve a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (id: string, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollection', 'id', id)
            const localVarPath = `/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the collections available in the project.
         * @summary List Collections
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections: async (offset?: number, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing collection.
         * @summary Update a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection: async (id: string, meta?: string, updateCollectionRequest?: UpdateCollectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCollection', 'id', id)
            const localVarPath = `/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new collection in Directus.
         * @summary Create a Collection
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(meta?: string, createCollectionRequest?: CreateCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollection(meta, createCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.createCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution.
         * @summary Delete a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollection(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.deleteCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of a single collection.
         * @summary Retrieve a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(id: string, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(id, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.getCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the collections available in the project.
         * @summary List Collections
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollections(offset?: number, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollections200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollections(offset, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.getCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing collection.
         * @summary Update a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollection(id: string, meta?: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollection(id, meta, updateCollectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CollectionsApi.updateCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * Create a new collection in Directus.
         * @summary Create a Collection
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(meta?: string, createCollectionRequest?: CreateCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCollection200Response> {
            return localVarFp.createCollection(meta, createCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution.
         * @summary Delete a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCollection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a single collection.
         * @summary Retrieve a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(id: string, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateCollection200Response> {
            return localVarFp.getCollection(id, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the collections available in the project.
         * @summary List Collections
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections(offset?: number, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCollections200Response> {
            return localVarFp.getCollections(offset, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing collection.
         * @summary Update a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateCollectionRequest} [updateCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(id: string, meta?: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCollection200Response> {
            return localVarFp.updateCollection(id, meta, updateCollectionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Create a new collection in Directus.
     * @summary Create a Collection
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateCollectionRequest} [createCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public createCollection(meta?: string, createCollectionRequest?: CreateCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).createCollection(meta, createCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution.
     * @summary Delete a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollection(id: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).deleteCollection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a single collection.
     * @summary Retrieve a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollection(id: string, meta?: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollection(id, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the collections available in the project.
     * @summary List Collections
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollections(offset?: number, meta?: string, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollections(offset, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing collection.
     * @summary Update a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {string} [meta] What metadata to return in the response.
     * @param {UpdateCollectionRequest} [updateCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public updateCollection(id: string, meta?: string, updateCollectionRequest?: UpdateCollectionRequest, options?: RawAxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).updateCollection(id, meta, updateCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommentsApi - axios parameter creator
 * @export
 */
export const CommentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new comment.
         * @summary Create a Comment
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateCommentRequest} [createCommentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (fields?: Array<string>, meta?: string, createCommentRequest?: CreateCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing comment.
         * @summary Delete a Comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/comments/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing comments.
         * @summary Delete Multiple Comments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComments: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single comment by unique identifier.
         * @summary Retrieve a Comment
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment: async (fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/comments/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the comments.
         * @summary List Comments
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (fields?: Array<string>, limit?: number, offset?: number, page?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing comment.
         * @summary Update a Comment
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateCommentRequest} [updateCommentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment: async (fields?: Array<string>, meta?: string, updateCommentRequest?: UpdateCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/comments/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCommentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple comments at the same time.
         * @summary Update Multiple Comments
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateCommentsRequest} [updateCommentsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComments: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateCommentsRequest?: UpdateCommentsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCommentsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsApi - functional programming interface
 * @export
 */
export const CommentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new comment.
         * @summary Create a Comment
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateCommentRequest} [createCommentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(fields?: Array<string>, meta?: string, createCommentRequest?: CreateCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateComment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(fields, meta, createCommentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.createComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing comment.
         * @summary Delete a Comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComment(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.deleteComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing comments.
         * @summary Delete Multiple Comments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComments(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComments(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.deleteComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single comment by unique identifier.
         * @summary Retrieve a Comment
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComment(fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateComment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComment(fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.getComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the comments.
         * @summary List Comments
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(fields?: Array<string>, limit?: number, offset?: number, page?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetComments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(fields, limit, offset, page, sort, filter, search, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.getComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing comment.
         * @summary Update a Comment
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateCommentRequest} [updateCommentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateComment(fields?: Array<string>, meta?: string, updateCommentRequest?: UpdateCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateComment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateComment(fields, meta, updateCommentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.updateComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple comments at the same time.
         * @summary Update Multiple Comments
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateCommentsRequest} [updateCommentsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateComments(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateCommentsRequest?: UpdateCommentsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetComments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateComments(fields, limit, meta, offset, sort, filter, search, updateCommentsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.updateComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommentsApi - factory interface
 * @export
 */
export const CommentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentsApiFp(configuration)
    return {
        /**
         * Create a new comment.
         * @summary Create a Comment
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateCommentRequest} [createCommentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(fields?: Array<string>, meta?: string, createCommentRequest?: CreateCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateComment200Response> {
            return localVarFp.createComment(fields, meta, createCommentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing comment.
         * @summary Delete a Comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteComment(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing comments.
         * @summary Delete Multiple Comments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComments(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteComments(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single comment by unique identifier.
         * @summary Retrieve a Comment
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment(fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateComment200Response> {
            return localVarFp.getComment(fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the comments.
         * @summary List Comments
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(fields?: Array<string>, limit?: number, offset?: number, page?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetComments200Response> {
            return localVarFp.getComments(fields, limit, offset, page, sort, filter, search, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing comment.
         * @summary Update a Comment
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateCommentRequest} [updateCommentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComment(fields?: Array<string>, meta?: string, updateCommentRequest?: UpdateCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateComment200Response> {
            return localVarFp.updateComment(fields, meta, updateCommentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple comments at the same time.
         * @summary Update Multiple Comments
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateCommentsRequest} [updateCommentsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComments(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateCommentsRequest?: UpdateCommentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetComments200Response> {
            return localVarFp.updateComments(fields, limit, meta, offset, sort, filter, search, updateCommentsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentsApi - object-oriented interface
 * @export
 * @class CommentsApi
 * @extends {BaseAPI}
 */
export class CommentsApi extends BaseAPI {
    /**
     * Create a new comment.
     * @summary Create a Comment
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateCommentRequest} [createCommentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public createComment(fields?: Array<string>, meta?: string, createCommentRequest?: CreateCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).createComment(fields, meta, createCommentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing comment.
     * @summary Delete a Comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public deleteComment(options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).deleteComment(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing comments.
     * @summary Delete Multiple Comments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public deleteComments(options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).deleteComments(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single comment by unique identifier.
     * @summary Retrieve a Comment
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public getComment(fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).getComment(fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the comments.
     * @summary List Comments
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public getComments(fields?: Array<string>, limit?: number, offset?: number, page?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).getComments(fields, limit, offset, page, sort, filter, search, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing comment.
     * @summary Update a Comment
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {UpdateCommentRequest} [updateCommentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public updateComment(fields?: Array<string>, meta?: string, updateCommentRequest?: UpdateCommentRequest, options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).updateComment(fields, meta, updateCommentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple comments at the same time.
     * @summary Update Multiple Comments
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdateCommentsRequest} [updateCommentsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public updateComments(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateCommentsRequest?: UpdateCommentsRequest, options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).updateComments(fields, limit, meta, offset, sort, filter, search, updateCommentsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExtensionsApi - axios parameter creator
 * @export
 */
export const ExtensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the installed extensions and their configuration in the project.
         * @summary List Extensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExtensions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing extension.
         * @summary Update an Extension
         * @param {string} bundle 
         * @param {string} name 
         * @param {UpdateExtensionsRequest} [updateExtensionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExtensionBundle: async (bundle: string, name: string, updateExtensionsRequest?: UpdateExtensionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundle' is not null or undefined
            assertParamExists('updateExtensionBundle', 'bundle', bundle)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateExtensionBundle', 'name', name)
            const localVarPath = `/extensions/{bundle}/{name}`
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateExtensionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing extension.
         * @summary Update an Extension
         * @param {string} name 
         * @param {UpdateExtensionsRequest} [updateExtensionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExtensions: async (name: string, updateExtensionsRequest?: UpdateExtensionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateExtensions', 'name', name)
            const localVarPath = `/extensions/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateExtensionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExtensionsApi - functional programming interface
 * @export
 */
export const ExtensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExtensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * List the installed extensions and their configuration in the project.
         * @summary List Extensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExtensions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExtensions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExtensions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.listExtensions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing extension.
         * @summary Update an Extension
         * @param {string} bundle 
         * @param {string} name 
         * @param {UpdateExtensionsRequest} [updateExtensionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExtensionBundle(bundle: string, name: string, updateExtensionsRequest?: UpdateExtensionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateExtensions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExtensionBundle(bundle, name, updateExtensionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.updateExtensionBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing extension.
         * @summary Update an Extension
         * @param {string} name 
         * @param {UpdateExtensionsRequest} [updateExtensionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExtensions(name: string, updateExtensionsRequest?: UpdateExtensionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateExtensions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExtensions(name, updateExtensionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.updateExtensions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExtensionsApi - factory interface
 * @export
 */
export const ExtensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExtensionsApiFp(configuration)
    return {
        /**
         * List the installed extensions and their configuration in the project.
         * @summary List Extensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExtensions(options?: RawAxiosRequestConfig): AxiosPromise<ListExtensions200Response> {
            return localVarFp.listExtensions(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing extension.
         * @summary Update an Extension
         * @param {string} bundle 
         * @param {string} name 
         * @param {UpdateExtensionsRequest} [updateExtensionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExtensionBundle(bundle: string, name: string, updateExtensionsRequest?: UpdateExtensionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateExtensions200Response> {
            return localVarFp.updateExtensionBundle(bundle, name, updateExtensionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing extension.
         * @summary Update an Extension
         * @param {string} name 
         * @param {UpdateExtensionsRequest} [updateExtensionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExtensions(name: string, updateExtensionsRequest?: UpdateExtensionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateExtensions200Response> {
            return localVarFp.updateExtensions(name, updateExtensionsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExtensionsApi - object-oriented interface
 * @export
 * @class ExtensionsApi
 * @extends {BaseAPI}
 */
export class ExtensionsApi extends BaseAPI {
    /**
     * List the installed extensions and their configuration in the project.
     * @summary List Extensions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public listExtensions(options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).listExtensions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing extension.
     * @summary Update an Extension
     * @param {string} bundle 
     * @param {string} name 
     * @param {UpdateExtensionsRequest} [updateExtensionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public updateExtensionBundle(bundle: string, name: string, updateExtensionsRequest?: UpdateExtensionsRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).updateExtensionBundle(bundle, name, updateExtensionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing extension.
     * @summary Update an Extension
     * @param {string} name 
     * @param {UpdateExtensionsRequest} [updateExtensionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public updateExtensions(name: string, updateExtensionsRequest?: UpdateExtensionsRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).updateExtensions(name, updateExtensionsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FieldsApi - axios parameter creator
 * @export
 */
export const FieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new field in a given collection.
         * @summary Create Field in Collection
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {CreateFieldRequest} [createFieldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createField: async (collection: string, createFieldRequest?: CreateFieldRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('createField', 'collection', collection)
            const localVarPath = `/fields/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFieldRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing field.
         * @summary Delete a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteField: async (collection: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('deleteField', 'collection', collection)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteField', 'id', id)
            const localVarPath = `/fields/{collection}/{id}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a single field in a given collection.
         * @summary Retrieve a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionField: async (collection: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('getCollectionField', 'collection', collection)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollectionField', 'id', id)
            const localVarPath = `/fields/{collection}/{id}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the fields available in the given collection.
         * @summary List Fields in Collection
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionFields: async (collection: string, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('getCollectionFields', 'collection', collection)
            const localVarPath = `/fields/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the fields available in the project.
         * @summary List All Fields
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFields: async (limit?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing field.
         * @summary Update a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {UpdateFieldRequest} [updateFieldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateField: async (collection: string, id: string, updateFieldRequest?: UpdateFieldRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('updateField', 'collection', collection)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateField', 'id', id)
            const localVarPath = `/fields/{collection}/{id}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFieldRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FieldsApi - functional programming interface
 * @export
 */
export const FieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new field in a given collection.
         * @summary Create Field in Collection
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {CreateFieldRequest} [createFieldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createField(collection: string, createFieldRequest?: CreateFieldRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateField200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createField(collection, createFieldRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FieldsApi.createField']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing field.
         * @summary Delete a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteField(collection: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteField(collection, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FieldsApi.deleteField']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of a single field in a given collection.
         * @summary Retrieve a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionField(collection: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateField200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionField(collection, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FieldsApi.getCollectionField']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the fields available in the given collection.
         * @summary List Fields in Collection
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionFields(collection: string, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFields200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionFields(collection, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FieldsApi.getCollectionFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the fields available in the project.
         * @summary List All Fields
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFields(limit?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFields200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFields(limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FieldsApi.getFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing field.
         * @summary Update a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {UpdateFieldRequest} [updateFieldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateField(collection: string, id: string, updateFieldRequest?: UpdateFieldRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateField200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateField(collection, id, updateFieldRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FieldsApi.updateField']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FieldsApi - factory interface
 * @export
 */
export const FieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FieldsApiFp(configuration)
    return {
        /**
         * Create a new field in a given collection.
         * @summary Create Field in Collection
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {CreateFieldRequest} [createFieldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createField(collection: string, createFieldRequest?: CreateFieldRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateField200Response> {
            return localVarFp.createField(collection, createFieldRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing field.
         * @summary Delete a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteField(collection: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteField(collection, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a single field in a given collection.
         * @summary Retrieve a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionField(collection: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateField200Response> {
            return localVarFp.getCollectionField(collection, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the fields available in the given collection.
         * @summary List Fields in Collection
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionFields(collection: string, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<GetFields200Response> {
            return localVarFp.getCollectionFields(collection, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the fields available in the project.
         * @summary List All Fields
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFields(limit?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<GetFields200Response> {
            return localVarFp.getFields(limit, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing field.
         * @summary Update a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {UpdateFieldRequest} [updateFieldRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateField(collection: string, id: string, updateFieldRequest?: UpdateFieldRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateField200Response> {
            return localVarFp.updateField(collection, id, updateFieldRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FieldsApi - object-oriented interface
 * @export
 * @class FieldsApi
 * @extends {BaseAPI}
 */
export class FieldsApi extends BaseAPI {
    /**
     * Create a new field in a given collection.
     * @summary Create Field in Collection
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {CreateFieldRequest} [createFieldRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public createField(collection: string, createFieldRequest?: CreateFieldRequest, options?: RawAxiosRequestConfig) {
        return FieldsApiFp(this.configuration).createField(collection, createFieldRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing field.
     * @summary Delete a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public deleteField(collection: string, id: string, options?: RawAxiosRequestConfig) {
        return FieldsApiFp(this.configuration).deleteField(collection, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a single field in a given collection.
     * @summary Retrieve a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public getCollectionField(collection: string, id: string, options?: RawAxiosRequestConfig) {
        return FieldsApiFp(this.configuration).getCollectionField(collection, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the fields available in the given collection.
     * @summary List Fields in Collection
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public getCollectionFields(collection: string, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return FieldsApiFp(this.configuration).getCollectionFields(collection, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the fields available in the project.
     * @summary List All Fields
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public getFields(limit?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return FieldsApiFp(this.configuration).getFields(limit, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing field.
     * @summary Update a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {UpdateFieldRequest} [updateFieldRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public updateField(collection: string, id: string, updateFieldRequest?: UpdateFieldRequest, options?: RawAxiosRequestConfig) {
        return FieldsApiFp(this.configuration).updateField(collection, id, updateFieldRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new file
         * @summary Create a File
         * @param {CreateFileRequest} [createFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (createFileRequest?: CreateFileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing file.
         * @summary Delete a File
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing files.
         * @summary Delete Multiple Files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single file by unique identifier.
         * @summary Retrieve a Files
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (id: string, fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the files.
         * @summary List Files
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles: async (fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing file, and/or replace it\'s file contents.
         * @summary Update a File
         * @param {string} id Unique identifier for the object.
         * @param {any} file File contents.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [title] Title for the file. Is extracted from the filename on upload, but can be edited by the user.
         * @param {string} [filenameDownload] Preferred filename when file is downloaded.
         * @param {string | null} [description] Description for the file.
         * @param {UpdateFileRequestFolder | null} [folder] 
         * @param {Array<string> | null} [tags] Tags for the file. Is automatically populated based on Exif data for images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile: async (id: string, file: any, fields?: Array<string>, meta?: string, title?: string, filenameDownload?: string, description?: string | null, folder?: UpdateFileRequestFolder | null, tags?: Array<string> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFile', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('updateFile', 'file', file)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


            if (title !== undefined) { 
                localVarFormParams.set('title', title as any);
            }
    
            if (filenameDownload !== undefined) { 
                localVarFormParams.set('filename_download', filenameDownload as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.set('description', description as any);
            }
    
            if (folder !== undefined) { 
                localVarFormParams.set('folder', folder as any);
            }
                if (tags) {
                localVarFormParams.set('tags', tags.join(COLLECTION_FORMATS.csv));
            }

    
            if (file !== undefined) { 
                localVarFormParams.set('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple files at the same time.
         * @summary Update Multiple Files
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateFilesRequest} [updateFilesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFiles: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFilesRequest?: UpdateFilesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFilesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new file
         * @summary Create a File
         * @param {CreateFileRequest} [createFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(createFileRequest?: CreateFileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(createFileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.createFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing file.
         * @summary Delete a File
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.deleteFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing files.
         * @summary Delete Multiple Files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.deleteFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single file by unique identifier.
         * @summary Retrieve a Files
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(id, fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the files.
         * @summary List Files
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFiles(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFiles(fields, limit, offset, sort, filter, search, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.getFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing file, and/or replace it\'s file contents.
         * @summary Update a File
         * @param {string} id Unique identifier for the object.
         * @param {any} file File contents.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [title] Title for the file. Is extracted from the filename on upload, but can be edited by the user.
         * @param {string} [filenameDownload] Preferred filename when file is downloaded.
         * @param {string | null} [description] Description for the file.
         * @param {UpdateFileRequestFolder | null} [folder] 
         * @param {Array<string> | null} [tags] Tags for the file. Is automatically populated based on Exif data for images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFile(id: string, file: any, fields?: Array<string>, meta?: string, title?: string, filenameDownload?: string, description?: string | null, folder?: UpdateFileRequestFolder | null, tags?: Array<string> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(id, file, fields, meta, title, filenameDownload, description, folder, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.updateFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple files at the same time.
         * @summary Update Multiple Files
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateFilesRequest} [updateFilesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFiles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFilesRequest?: UpdateFilesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFiles(fields, limit, meta, offset, sort, filter, search, updateFilesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.updateFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Create a new file
         * @summary Create a File
         * @param {CreateFileRequest} [createFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(createFileRequest?: CreateFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateFile200Response> {
            return localVarFp.createFile(createFileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing file.
         * @summary Delete a File
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing files.
         * @summary Delete Multiple Files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFiles(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single file by unique identifier.
         * @summary Retrieve a Files
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateFile200Response> {
            return localVarFp.getFile(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the files.
         * @summary List Files
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetFiles200Response> {
            return localVarFp.getFiles(fields, limit, offset, sort, filter, search, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing file, and/or replace it\'s file contents.
         * @summary Update a File
         * @param {string} id Unique identifier for the object.
         * @param {any} file File contents.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [title] Title for the file. Is extracted from the filename on upload, but can be edited by the user.
         * @param {string} [filenameDownload] Preferred filename when file is downloaded.
         * @param {string | null} [description] Description for the file.
         * @param {UpdateFileRequestFolder | null} [folder] 
         * @param {Array<string> | null} [tags] Tags for the file. Is automatically populated based on Exif data for images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(id: string, file: any, fields?: Array<string>, meta?: string, title?: string, filenameDownload?: string, description?: string | null, folder?: UpdateFileRequestFolder | null, tags?: Array<string> | null, options?: RawAxiosRequestConfig): AxiosPromise<CreateFile200Response> {
            return localVarFp.updateFile(id, file, fields, meta, title, filenameDownload, description, folder, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple files at the same time.
         * @summary Update Multiple Files
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateFilesRequest} [updateFilesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFiles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFilesRequest?: UpdateFilesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetFiles200Response> {
            return localVarFp.updateFiles(fields, limit, meta, offset, sort, filter, search, updateFilesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Create a new file
     * @summary Create a File
     * @param {CreateFileRequest} [createFileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public createFile(createFileRequest?: CreateFileRequest, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).createFile(createFileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing file.
     * @summary Delete a File
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFile(id: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing files.
     * @summary Delete Multiple Files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFiles(options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single file by unique identifier.
     * @summary Retrieve a Files
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the files.
     * @summary List Files
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFiles(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFiles(fields, limit, offset, sort, filter, search, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing file, and/or replace it\'s file contents.
     * @summary Update a File
     * @param {string} id Unique identifier for the object.
     * @param {any} file File contents.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {string} [title] Title for the file. Is extracted from the filename on upload, but can be edited by the user.
     * @param {string} [filenameDownload] Preferred filename when file is downloaded.
     * @param {string | null} [description] Description for the file.
     * @param {UpdateFileRequestFolder | null} [folder] 
     * @param {Array<string> | null} [tags] Tags for the file. Is automatically populated based on Exif data for images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public updateFile(id: string, file: any, fields?: Array<string>, meta?: string, title?: string, filenameDownload?: string, description?: string | null, folder?: UpdateFileRequestFolder | null, tags?: Array<string> | null, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).updateFile(id, file, fields, meta, title, filenameDownload, description, folder, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple files at the same time.
     * @summary Update Multiple Files
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdateFilesRequest} [updateFilesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public updateFiles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFilesRequest?: UpdateFilesRequest, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).updateFiles(fields, limit, meta, offset, sort, filter, search, updateFilesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowsApi - axios parameter creator
 * @export
 */
export const FlowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new flow.
         * @summary Create a Flow
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Flows} [flows] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlow: async (fields?: Array<string>, meta?: string, flows?: Flows, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flows, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing flow
         * @summary Delete a Flow
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlow: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFlow', 'id', id)
            const localVarPath = `/flows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing flows.
         * @summary Delete Multiple Flows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlows: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single flow by unique identifier.
         * @summary Retrieve a Flow
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlow: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFlow', 'id', id)
            const localVarPath = `/flows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all flows.
         * @summary List Flows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlows: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing flow
         * @summary Update a Flow
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Flows} [flows] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlow: async (id: string, fields?: Array<string>, meta?: string, flows?: Flows, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFlow', 'id', id)
            const localVarPath = `/flows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flows, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple flows at the same time.
         * @summary Update Multiple Flows
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateFlowsRequest} [updateFlowsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlows: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFlowsRequest?: UpdateFlowsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFlowsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowsApi - functional programming interface
 * @export
 */
export const FlowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new flow.
         * @summary Create a Flow
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Flows} [flows] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlow(fields?: Array<string>, meta?: string, flows?: Flows, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFlow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlow(fields, meta, flows, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing flow
         * @summary Delete a Flow
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlow(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlow(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.deleteFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing flows.
         * @summary Delete Multiple Flows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlows(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlows(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.deleteFlows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single flow by unique identifier.
         * @summary Retrieve a Flow
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlow(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFlow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlow(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all flows.
         * @summary List Flows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlows(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFlows200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlows(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getFlows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing flow
         * @summary Update a Flow
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Flows} [flows] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlow(id: string, fields?: Array<string>, meta?: string, flows?: Flows, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFlow200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlow(id, fields, meta, flows, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.updateFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple flows at the same time.
         * @summary Update Multiple Flows
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateFlowsRequest} [updateFlowsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlows(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFlowsRequest?: UpdateFlowsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFlows200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlows(fields, limit, meta, offset, sort, filter, search, updateFlowsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.updateFlows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowsApi - factory interface
 * @export
 */
export const FlowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowsApiFp(configuration)
    return {
        /**
         * Create a new flow.
         * @summary Create a Flow
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Flows} [flows] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlow(fields?: Array<string>, meta?: string, flows?: Flows, options?: RawAxiosRequestConfig): AxiosPromise<CreateFlow200Response> {
            return localVarFp.createFlow(fields, meta, flows, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing flow
         * @summary Delete a Flow
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlow(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFlow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing flows.
         * @summary Delete Multiple Flows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlows(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFlows(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single flow by unique identifier.
         * @summary Retrieve a Flow
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlow(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateFlow200Response> {
            return localVarFp.getFlow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all flows.
         * @summary List Flows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlows(options?: RawAxiosRequestConfig): AxiosPromise<GetFlows200Response> {
            return localVarFp.getFlows(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing flow
         * @summary Update a Flow
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Flows} [flows] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlow(id: string, fields?: Array<string>, meta?: string, flows?: Flows, options?: RawAxiosRequestConfig): AxiosPromise<CreateFlow200Response> {
            return localVarFp.updateFlow(id, fields, meta, flows, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple flows at the same time.
         * @summary Update Multiple Flows
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateFlowsRequest} [updateFlowsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlows(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFlowsRequest?: UpdateFlowsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetFlows200Response> {
            return localVarFp.updateFlows(fields, limit, meta, offset, sort, filter, search, updateFlowsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowsApi - object-oriented interface
 * @export
 * @class FlowsApi
 * @extends {BaseAPI}
 */
export class FlowsApi extends BaseAPI {
    /**
     * Create a new flow.
     * @summary Create a Flow
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Flows} [flows] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createFlow(fields?: Array<string>, meta?: string, flows?: Flows, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createFlow(fields, meta, flows, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing flow
     * @summary Delete a Flow
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public deleteFlow(id: string, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).deleteFlow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing flows.
     * @summary Delete Multiple Flows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public deleteFlows(options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).deleteFlows(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single flow by unique identifier.
     * @summary Retrieve a Flow
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getFlow(id: string, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getFlow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all flows.
     * @summary List Flows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getFlows(options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getFlows(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing flow
     * @summary Update a Flow
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Flows} [flows] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public updateFlow(id: string, fields?: Array<string>, meta?: string, flows?: Flows, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).updateFlow(id, fields, meta, flows, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple flows at the same time.
     * @summary Update Multiple Flows
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdateFlowsRequest} [updateFlowsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public updateFlows(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFlowsRequest?: UpdateFlowsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).updateFlows(fields, limit, meta, offset, sort, filter, search, updateFlowsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new folder.
         * @summary Create a Folder
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateFolderRequest} [createFolderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (fields?: Array<string>, meta?: string, createFolderRequest?: CreateFolderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFolderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing folder
         * @summary Delete a Folder
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFolder', 'id', id)
            const localVarPath = `/folders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing folders.
         * @summary Delete Multiple Folders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single folder by unique identifier.
         * @summary Retrieve a Folder
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (id: string, fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFolder', 'id', id)
            const localVarPath = `/folders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the folders.
         * @summary List Folders
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders: async (fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing folder
         * @summary Update a Folder
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateFolderRequest} [updateFolderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolder: async (id: string, fields?: Array<string>, meta?: string, updateFolderRequest?: UpdateFolderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFolder', 'id', id)
            const localVarPath = `/folders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFolderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple folders at the same time.
         * @summary Update Multiple Folders
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateFoldersRequest} [updateFoldersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolders: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFoldersRequest?: UpdateFoldersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFoldersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new folder.
         * @summary Create a Folder
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateFolderRequest} [createFolderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(fields?: Array<string>, meta?: string, createFolderRequest?: CreateFolderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFolder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(fields, meta, createFolderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.createFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing folder
         * @summary Delete a Folder
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.deleteFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing folders.
         * @summary Delete Multiple Folders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.deleteFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single folder by unique identifier.
         * @summary Retrieve a Folder
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFolder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(id, fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.getFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the folders.
         * @summary List Folders
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolders(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFolders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolders(fields, limit, offset, sort, filter, search, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.getFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing folder
         * @summary Update a Folder
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateFolderRequest} [updateFolderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolder(id: string, fields?: Array<string>, meta?: string, updateFolderRequest?: UpdateFolderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFolder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolder(id, fields, meta, updateFolderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.updateFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple folders at the same time.
         * @summary Update Multiple Folders
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateFoldersRequest} [updateFoldersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolders(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFoldersRequest?: UpdateFoldersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFolders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolders(fields, limit, meta, offset, sort, filter, search, updateFoldersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.updateFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * Create a new folder.
         * @summary Create a Folder
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateFolderRequest} [createFolderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(fields?: Array<string>, meta?: string, createFolderRequest?: CreateFolderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateFolder200Response> {
            return localVarFp.createFolder(fields, meta, createFolderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing folder
         * @summary Delete a Folder
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFolder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing folders.
         * @summary Delete Multiple Folders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolders(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFolders(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single folder by unique identifier.
         * @summary Retrieve a Folder
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateFolder200Response> {
            return localVarFp.getFolder(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the folders.
         * @summary List Folders
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetFolders200Response> {
            return localVarFp.getFolders(fields, limit, offset, sort, filter, search, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing folder
         * @summary Update a Folder
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateFolderRequest} [updateFolderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolder(id: string, fields?: Array<string>, meta?: string, updateFolderRequest?: UpdateFolderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateFolder200Response> {
            return localVarFp.updateFolder(id, fields, meta, updateFolderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple folders at the same time.
         * @summary Update Multiple Folders
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateFoldersRequest} [updateFoldersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolders(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFoldersRequest?: UpdateFoldersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetFolders200Response> {
            return localVarFp.updateFolders(fields, limit, meta, offset, sort, filter, search, updateFoldersRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * Create a new folder.
     * @summary Create a Folder
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateFolderRequest} [createFolderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createFolder(fields?: Array<string>, meta?: string, createFolderRequest?: CreateFolderRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).createFolder(fields, meta, createFolderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing folder
     * @summary Delete a Folder
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolder(id: string, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).deleteFolder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing folders.
     * @summary Delete Multiple Folders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolders(options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).deleteFolders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single folder by unique identifier.
     * @summary Retrieve a Folder
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolder(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolder(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the folders.
     * @summary List Folders
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolders(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolders(fields, limit, offset, sort, filter, search, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing folder
     * @summary Update a Folder
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {UpdateFolderRequest} [updateFolderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public updateFolder(id: string, fields?: Array<string>, meta?: string, updateFolderRequest?: UpdateFolderRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).updateFolder(id, fields, meta, updateFolderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple folders at the same time.
     * @summary Update Multiple Folders
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdateFoldersRequest} [updateFoldersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public updateFolders(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateFoldersRequest?: UpdateFoldersRequest, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).updateFolders(fields, limit, meta, offset, sort, filter, search, updateFoldersRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new articles item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticles: async (meta?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsArticlesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new users item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsUsers: async (meta?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing articles items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsArticles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing users items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing articles item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticles: async (id: ReadSingleItemsArticlesIdParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsArticles', 'id', id)
            const localVarPath = `/items/articles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing users item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsUsers: async (id: ReadSingleItemsArticlesIdParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsUsers', 'id', id)
            const localVarPath = `/items/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the articles items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticles: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the users items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsUsers: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single articles item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticles: async (id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsArticles', 'id', id)
            const localVarPath = `/items/articles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single users item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsUsers: async (id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsUsers', 'id', id)
            const localVarPath = `/items/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple articles items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemsArticles: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsArticlesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple users items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemsUsers: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing articles item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticles} [itemsArticles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticles: async (id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsArticles?: ItemsArticles, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsArticles', 'id', id)
            const localVarPath = `/items/articles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsArticles, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing users item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsUsers} [itemsUsers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsUsers: async (id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsUsers?: ItemsUsers, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsUsers', 'id', id)
            const localVarPath = `/items/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsUsers, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new articles item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsArticles(meta?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsArticles(meta, createItemsArticlesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.createItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new users item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsUsers(meta?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsUsers(meta, createItemsUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.createItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing articles items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemsArticles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemsArticles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.deleteItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing users items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemsUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemsUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.deleteItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing articles item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsArticles(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.deleteSingleItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing users item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsUsers(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.deleteSingleItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the articles items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsArticles(fields, limit, meta, offset, sort, filter, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.readItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the users items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsUsers(fields, limit, meta, offset, sort, filter, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.readItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single articles item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsArticles(id, fields, meta, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.readSingleItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single users item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsUsers(id, fields, meta, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.readSingleItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple articles items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateItemsArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemsArticles(fields, limit, meta, offset, sort, filter, search, createItemsArticlesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.updateItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple users items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateItemsUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemsUsers(fields, limit, meta, offset, sort, filter, search, createItemsUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.updateItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing articles item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticles} [itemsArticles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsArticles?: ItemsArticles, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsArticles(id, fields, meta, itemsArticles, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.updateSingleItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing users item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsUsers} [itemsUsers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsUsers?: ItemsUsers, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsUsers(id, fields, meta, itemsUsers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.updateSingleItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * Create a new articles item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticles(meta?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateItemsArticles200Response> {
            return localVarFp.createItemsArticles(meta, createItemsArticlesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new users item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsUsers(meta?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateItemsUsers200Response> {
            return localVarFp.createItemsUsers(meta, createItemsUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing articles items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsArticles(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteItemsArticles(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing users items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsUsers(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteItemsUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing articles item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsArticles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing users item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the articles items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReadItemsArticles200Response> {
            return localVarFp.readItemsArticles(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the users items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReadItemsUsers200Response> {
            return localVarFp.readItemsUsers(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single articles item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReadSingleItemsArticles200Response> {
            return localVarFp.readSingleItemsArticles(id, fields, meta, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single users item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReadSingleItemsUsers200Response> {
            return localVarFp.readSingleItemsUsers(id, fields, meta, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple articles items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateItemsArticles200Response> {
            return localVarFp.updateItemsArticles(fields, limit, meta, offset, sort, filter, search, createItemsArticlesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple users items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateItemsUsers200Response> {
            return localVarFp.updateItemsUsers(fields, limit, meta, offset, sort, filter, search, createItemsUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing articles item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticles} [itemsArticles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsArticles?: ItemsArticles, options?: RawAxiosRequestConfig): AxiosPromise<ReadSingleItemsArticles200Response> {
            return localVarFp.updateSingleItemsArticles(id, fields, meta, itemsArticles, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing users item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsUsers} [itemsUsers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsUsers?: ItemsUsers, options?: RawAxiosRequestConfig): AxiosPromise<ReadSingleItemsUsers200Response> {
            return localVarFp.updateSingleItemsUsers(id, fields, meta, itemsUsers, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * Create a new articles item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsArticles(meta?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsArticles(meta, createItemsArticlesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new users item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsUsers(meta?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsUsers(meta, createItemsUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing articles items.
     * @summary Delete Multiple Items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteItemsArticles(options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteItemsArticles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing users items.
     * @summary Delete Multiple Items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteItemsUsers(options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteItemsUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing articles item.
     * @summary Delete an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsArticles(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing users item.
     * @summary Delete an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsUsers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the articles items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsArticles(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the users items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsUsers(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single articles item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsArticles(id, fields, meta, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single users item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsUsers(id, fields, meta, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple articles items at the same time.
     * @summary Update Multiple Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateItemsArticles(fields, limit, meta, offset, sort, filter, search, createItemsArticlesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple users items at the same time.
     * @summary Update Multiple Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateItemsUsers(fields, limit, meta, offset, sort, filter, search, createItemsUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing articles item.
     * @summary Update an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsArticles} [itemsArticles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsArticles?: ItemsArticles, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsArticles(id, fields, meta, itemsArticles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing users item.
     * @summary Update an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsUsers} [itemsUsers] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsUsers?: ItemsUsers, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsUsers(id, fields, meta, itemsUsers, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemsArticlesApi - axios parameter creator
 * @export
 */
export const ItemsArticlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new articles item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticles: async (meta?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsArticlesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing articles items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsArticles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing articles item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticles: async (id: ReadSingleItemsArticlesIdParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsArticles', 'id', id)
            const localVarPath = `/items/articles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the articles items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticles: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single articles item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticles: async (id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsArticles', 'id', id)
            const localVarPath = `/items/articles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple articles items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemsArticles: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/articles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsArticlesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing articles item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticles} [itemsArticles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticles: async (id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsArticles?: ItemsArticles, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsArticles', 'id', id)
            const localVarPath = `/items/articles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsArticles, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsArticlesApi - functional programming interface
 * @export
 */
export const ItemsArticlesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsArticlesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new articles item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsArticles(meta?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsArticles(meta, createItemsArticlesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsArticlesApi.createItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing articles items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemsArticles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemsArticles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsArticlesApi.deleteItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing articles item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsArticles(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsArticlesApi.deleteSingleItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the articles items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsArticles(fields, limit, meta, offset, sort, filter, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsArticlesApi.readItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single articles item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsArticles(id, fields, meta, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsArticlesApi.readSingleItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple articles items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateItemsArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemsArticles(fields, limit, meta, offset, sort, filter, search, createItemsArticlesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsArticlesApi.updateItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing articles item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticles} [itemsArticles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsArticles?: ItemsArticles, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsArticles(id, fields, meta, itemsArticles, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsArticlesApi.updateSingleItemsArticles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsArticlesApi - factory interface
 * @export
 */
export const ItemsArticlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsArticlesApiFp(configuration)
    return {
        /**
         * Create a new articles item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticles(meta?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateItemsArticles200Response> {
            return localVarFp.createItemsArticles(meta, createItemsArticlesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing articles items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsArticles(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteItemsArticles(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing articles item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsArticles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the articles items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReadItemsArticles200Response> {
            return localVarFp.readItemsArticles(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single articles item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReadSingleItemsArticles200Response> {
            return localVarFp.readSingleItemsArticles(id, fields, meta, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple articles items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateItemsArticles200Response> {
            return localVarFp.updateItemsArticles(fields, limit, meta, offset, sort, filter, search, createItemsArticlesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing articles item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticles} [itemsArticles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsArticles?: ItemsArticles, options?: RawAxiosRequestConfig): AxiosPromise<ReadSingleItemsArticles200Response> {
            return localVarFp.updateSingleItemsArticles(id, fields, meta, itemsArticles, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsArticlesApi - object-oriented interface
 * @export
 * @class ItemsArticlesApi
 * @extends {BaseAPI}
 */
export class ItemsArticlesApi extends BaseAPI {
    /**
     * Create a new articles item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticlesApi
     */
    public createItemsArticles(meta?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig) {
        return ItemsArticlesApiFp(this.configuration).createItemsArticles(meta, createItemsArticlesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing articles items.
     * @summary Delete Multiple Items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticlesApi
     */
    public deleteItemsArticles(options?: RawAxiosRequestConfig) {
        return ItemsArticlesApiFp(this.configuration).deleteItemsArticles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing articles item.
     * @summary Delete an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticlesApi
     */
    public deleteSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig) {
        return ItemsArticlesApiFp(this.configuration).deleteSingleItemsArticles(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the articles items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticlesApi
     */
    public readItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig) {
        return ItemsArticlesApiFp(this.configuration).readItemsArticles(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single articles item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticlesApi
     */
    public readSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig) {
        return ItemsArticlesApiFp(this.configuration).readSingleItemsArticles(id, fields, meta, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple articles items at the same time.
     * @summary Update Multiple Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {CreateItemsArticlesRequest} [createItemsArticlesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticlesApi
     */
    public updateItemsArticles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsArticlesRequest?: CreateItemsArticlesRequest, options?: RawAxiosRequestConfig) {
        return ItemsArticlesApiFp(this.configuration).updateItemsArticles(fields, limit, meta, offset, sort, filter, search, createItemsArticlesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing articles item.
     * @summary Update an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsArticles} [itemsArticles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticlesApi
     */
    public updateSingleItemsArticles(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsArticles?: ItemsArticles, options?: RawAxiosRequestConfig) {
        return ItemsArticlesApiFp(this.configuration).updateSingleItemsArticles(id, fields, meta, itemsArticles, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemsUsersApi - axios parameter creator
 * @export
 */
export const ItemsUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new users item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsUsers: async (meta?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing users items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing users item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsUsers: async (id: ReadSingleItemsArticlesIdParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsUsers', 'id', id)
            const localVarPath = `/items/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the users items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsUsers: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single users item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsUsers: async (id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsUsers', 'id', id)
            const localVarPath = `/items/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple users items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemsUsers: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing users item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsUsers} [itemsUsers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsUsers: async (id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsUsers?: ItemsUsers, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsUsers', 'id', id)
            const localVarPath = `/items/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsUsers, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsUsersApi - functional programming interface
 * @export
 */
export const ItemsUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new users item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsUsers(meta?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsUsers(meta, createItemsUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsUsersApi.createItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing users items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemsUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemsUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsUsersApi.deleteItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing users item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsUsers(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsUsersApi.deleteSingleItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the users items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsUsers(fields, limit, meta, offset, sort, filter, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsUsersApi.readItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single users item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsUsers(id, fields, meta, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsUsersApi.readSingleItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple users items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateItemsUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemsUsers(fields, limit, meta, offset, sort, filter, search, createItemsUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsUsersApi.updateItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing users item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsUsers} [itemsUsers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsUsers?: ItemsUsers, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsUsers(id, fields, meta, itemsUsers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsUsersApi.updateSingleItemsUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsUsersApi - factory interface
 * @export
 */
export const ItemsUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsUsersApiFp(configuration)
    return {
        /**
         * Create a new users item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsUsers(meta?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateItemsUsers200Response> {
            return localVarFp.createItemsUsers(meta, createItemsUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing users items.
         * @summary Delete Multiple Items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemsUsers(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteItemsUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing users item.
         * @summary Delete an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the users items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReadItemsUsers200Response> {
            return localVarFp.readItemsUsers(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single users item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReadSingleItemsUsers200Response> {
            return localVarFp.readSingleItemsUsers(id, fields, meta, version, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple users items at the same time.
         * @summary Update Multiple Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateItemsUsers200Response> {
            return localVarFp.updateItemsUsers(fields, limit, meta, offset, sort, filter, search, createItemsUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing users item.
         * @summary Update an Item
         * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsUsers} [itemsUsers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsUsers?: ItemsUsers, options?: RawAxiosRequestConfig): AxiosPromise<ReadSingleItemsUsers200Response> {
            return localVarFp.updateSingleItemsUsers(id, fields, meta, itemsUsers, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsUsersApi - object-oriented interface
 * @export
 * @class ItemsUsersApi
 * @extends {BaseAPI}
 */
export class ItemsUsersApi extends BaseAPI {
    /**
     * Create a new users item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsUsersApi
     */
    public createItemsUsers(meta?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig) {
        return ItemsUsersApiFp(this.configuration).createItemsUsers(meta, createItemsUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing users items.
     * @summary Delete Multiple Items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsUsersApi
     */
    public deleteItemsUsers(options?: RawAxiosRequestConfig) {
        return ItemsUsersApiFp(this.configuration).deleteItemsUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing users item.
     * @summary Delete an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsUsersApi
     */
    public deleteSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, options?: RawAxiosRequestConfig) {
        return ItemsUsersApiFp(this.configuration).deleteSingleItemsUsers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the users items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsUsersApi
     */
    public readItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig) {
        return ItemsUsersApiFp(this.configuration).readItemsUsers(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single users item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {string} [version] Retrieve an item\&#39;s state from a specific Content Version. The value corresponds to the \&quot;key\&quot; of the Content Version. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsUsersApi
     */
    public readSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, version?: string, options?: RawAxiosRequestConfig) {
        return ItemsUsersApiFp(this.configuration).readSingleItemsUsers(id, fields, meta, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple users items at the same time.
     * @summary Update Multiple Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {CreateItemsUsersRequest} [createItemsUsersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsUsersApi
     */
    public updateItemsUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, createItemsUsersRequest?: CreateItemsUsersRequest, options?: RawAxiosRequestConfig) {
        return ItemsUsersApiFp(this.configuration).updateItemsUsers(fields, limit, meta, offset, sort, filter, search, createItemsUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing users item.
     * @summary Update an Item
     * @param {ReadSingleItemsArticlesIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsUsers} [itemsUsers] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsUsersApi
     */
    public updateSingleItemsUsers(id: ReadSingleItemsArticlesIdParameter, fields?: Array<string>, meta?: string, itemsUsers?: ItemsUsers, options?: RawAxiosRequestConfig) {
        return ItemsUsersApiFp(this.configuration).updateSingleItemsUsers(id, fields, meta, itemsUsers, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OperationsApi - axios parameter creator
 * @export
 */
export const OperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new operation.
         * @summary Create an Operation
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Operations} [operations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperation: async (fields?: Array<string>, meta?: string, operations?: Operations, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operations, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing operation
         * @summary Delete an Operation
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOperation', 'id', id)
            const localVarPath = `/operations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing operations.
         * @summary Delete Multiple Operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single operation by unique identifier.
         * @summary Retrieve an Operation
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOperation', 'id', id)
            const localVarPath = `/operations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all operations.
         * @summary List Operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing operation
         * @summary Update an Operation
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Operations} [operations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperation: async (id: string, fields?: Array<string>, meta?: string, operations?: Operations, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOperation', 'id', id)
            const localVarPath = `/operations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operations, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple operations at the same time.
         * @summary Update Multiple Operations
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateOperationsRequest} [updateOperationsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperations: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateOperationsRequest?: UpdateOperationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOperationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationsApi - functional programming interface
 * @export
 */
export const OperationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new operation.
         * @summary Create an Operation
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Operations} [operations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOperation(fields?: Array<string>, meta?: string, operations?: Operations, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOperation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOperation(fields, meta, operations, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.createOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing operation
         * @summary Delete an Operation
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOperation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOperation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.deleteOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing operations.
         * @summary Delete Multiple Operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOperations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOperations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.deleteOperations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single operation by unique identifier.
         * @summary Retrieve an Operation
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOperation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOperation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.getOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all operations.
         * @summary List Operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOperations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOperations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.getOperations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing operation
         * @summary Update an Operation
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Operations} [operations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOperation(id: string, fields?: Array<string>, meta?: string, operations?: Operations, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOperation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOperation(id, fields, meta, operations, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.updateOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple operations at the same time.
         * @summary Update Multiple Operations
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateOperationsRequest} [updateOperationsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOperations(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateOperationsRequest?: UpdateOperationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOperations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOperations(fields, limit, meta, offset, sort, filter, search, updateOperationsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.updateOperations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OperationsApi - factory interface
 * @export
 */
export const OperationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperationsApiFp(configuration)
    return {
        /**
         * Create a new operation.
         * @summary Create an Operation
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Operations} [operations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperation(fields?: Array<string>, meta?: string, operations?: Operations, options?: RawAxiosRequestConfig): AxiosPromise<CreateOperation200Response> {
            return localVarFp.createOperation(fields, meta, operations, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing operation
         * @summary Delete an Operation
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOperation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing operations.
         * @summary Delete Multiple Operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperations(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOperations(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single operation by unique identifier.
         * @summary Retrieve an Operation
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateOperation200Response> {
            return localVarFp.getOperation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all operations.
         * @summary List Operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperations(options?: RawAxiosRequestConfig): AxiosPromise<GetOperations200Response> {
            return localVarFp.getOperations(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing operation
         * @summary Update an Operation
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Operations} [operations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperation(id: string, fields?: Array<string>, meta?: string, operations?: Operations, options?: RawAxiosRequestConfig): AxiosPromise<CreateOperation200Response> {
            return localVarFp.updateOperation(id, fields, meta, operations, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple operations at the same time.
         * @summary Update Multiple Operations
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateOperationsRequest} [updateOperationsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperations(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateOperationsRequest?: UpdateOperationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetOperations200Response> {
            return localVarFp.updateOperations(fields, limit, meta, offset, sort, filter, search, updateOperationsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationsApi - object-oriented interface
 * @export
 * @class OperationsApi
 * @extends {BaseAPI}
 */
export class OperationsApi extends BaseAPI {
    /**
     * Create a new operation.
     * @summary Create an Operation
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Operations} [operations] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public createOperation(fields?: Array<string>, meta?: string, operations?: Operations, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).createOperation(fields, meta, operations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing operation
     * @summary Delete an Operation
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public deleteOperation(id: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).deleteOperation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing operations.
     * @summary Delete Multiple Operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public deleteOperations(options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).deleteOperations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single operation by unique identifier.
     * @summary Retrieve an Operation
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public getOperation(id: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).getOperation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all operations.
     * @summary List Operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public getOperations(options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).getOperations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing operation
     * @summary Update an Operation
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Operations} [operations] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public updateOperation(id: string, fields?: Array<string>, meta?: string, operations?: Operations, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).updateOperation(id, fields, meta, operations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple operations at the same time.
     * @summary Update Multiple Operations
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdateOperationsRequest} [updateOperationsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public updateOperations(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateOperationsRequest?: UpdateOperationsRequest, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).updateOperations(fields, limit, meta, offset, sort, filter, search, updateOperationsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new permission.
         * @summary Create a Permission
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreatePermissionRequest} [createPermissionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermission: async (meta?: string, createPermissionRequest?: CreatePermissionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPermissionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing permission
         * @summary Delete a Permission
         * @param {number} id Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePermission', 'id', id)
            const localVarPath = `/permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing permissions.
         * @summary Delete Multiple Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the permissions that apply to the current user.
         * @summary List My Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single permissions object by unique identifier.
         * @summary Retrieve a Permission
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission: async (id: number, fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPermission', 'id', id)
            const localVarPath = `/permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all permissions.
         * @summary List Permissions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissions: async (fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing permission
         * @summary Update a Permission
         * @param {number} id Index
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdatePermissionRequest} [updatePermissionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermission: async (id: number, meta?: string, updatePermissionRequest?: UpdatePermissionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePermission', 'id', id)
            const localVarPath = `/permissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePermissionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple permissions at the same time.
         * @summary Update Multiple Permissions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdatePermissionsRequest} [updatePermissionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermissions: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updatePermissionsRequest?: UpdatePermissionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePermissionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new permission.
         * @summary Create a Permission
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreatePermissionRequest} [createPermissionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPermission(meta?: string, createPermissionRequest?: CreatePermissionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePermission200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPermission(meta, createPermissionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.createPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing permission
         * @summary Delete a Permission
         * @param {number} id Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermission(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermission(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.deletePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing permissions.
         * @summary Delete Multiple Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.deletePermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the permissions that apply to the current user.
         * @summary List My Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyPermissions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getMyPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single permissions object by unique identifier.
         * @summary Retrieve a Permission
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermission(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePermission200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermission(id, fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all permissions.
         * @summary List Permissions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissions(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPermissions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissions(fields, limit, offset, meta, sort, filter, search, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.getPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing permission
         * @summary Update a Permission
         * @param {number} id Index
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdatePermissionRequest} [updatePermissionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermission(id: number, meta?: string, updatePermissionRequest?: UpdatePermissionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePermission200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermission(id, meta, updatePermissionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.updatePermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple permissions at the same time.
         * @summary Update Multiple Permissions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdatePermissionsRequest} [updatePermissionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermissions(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updatePermissionsRequest?: UpdatePermissionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPermissions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermissions(fields, limit, meta, offset, sort, filter, search, updatePermissionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.updatePermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * Create a new permission.
         * @summary Create a Permission
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreatePermissionRequest} [createPermissionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermission(meta?: string, createPermissionRequest?: CreatePermissionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePermission200Response> {
            return localVarFp.createPermission(meta, createPermissionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing permission
         * @summary Delete a Permission
         * @param {number} id Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermission(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePermission(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing permissions.
         * @summary Delete Multiple Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermissions(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * List the permissions that apply to the current user.
         * @summary List My Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPermissions(options?: RawAxiosRequestConfig): AxiosPromise<GetMyPermissions200Response> {
            return localVarFp.getMyPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single permissions object by unique identifier.
         * @summary Retrieve a Permission
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermission(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePermission200Response> {
            return localVarFp.getPermission(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List all permissions.
         * @summary List Permissions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissions(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetPermissions200Response> {
            return localVarFp.getPermissions(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing permission
         * @summary Update a Permission
         * @param {number} id Index
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdatePermissionRequest} [updatePermissionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermission(id: number, meta?: string, updatePermissionRequest?: UpdatePermissionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePermission200Response> {
            return localVarFp.updatePermission(id, meta, updatePermissionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple permissions at the same time.
         * @summary Update Multiple Permissions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdatePermissionsRequest} [updatePermissionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermissions(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updatePermissionsRequest?: UpdatePermissionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetPermissions200Response> {
            return localVarFp.updatePermissions(fields, limit, meta, offset, sort, filter, search, updatePermissionsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     * Create a new permission.
     * @summary Create a Permission
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreatePermissionRequest} [createPermissionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public createPermission(meta?: string, createPermissionRequest?: CreatePermissionRequest, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).createPermission(meta, createPermissionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing permission
     * @summary Delete a Permission
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public deletePermission(id: number, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).deletePermission(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing permissions.
     * @summary Delete Multiple Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public deletePermissions(options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).deletePermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the permissions that apply to the current user.
     * @summary List My Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getMyPermissions(options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getMyPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single permissions object by unique identifier.
     * @summary Retrieve a Permission
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getPermission(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getPermission(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all permissions.
     * @summary List Permissions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getPermissions(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).getPermissions(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing permission
     * @summary Update a Permission
     * @param {number} id Index
     * @param {string} [meta] What metadata to return in the response.
     * @param {UpdatePermissionRequest} [updatePermissionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public updatePermission(id: number, meta?: string, updatePermissionRequest?: UpdatePermissionRequest, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).updatePermission(id, meta, updatePermissionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple permissions at the same time.
     * @summary Update Multiple Permissions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdatePermissionsRequest} [updatePermissionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public updatePermissions(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updatePermissionsRequest?: UpdatePermissionsRequest, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).updatePermissions(fields, limit, meta, offset, sort, filter, search, updatePermissionsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PresetsApi - axios parameter creator
 * @export
 */
export const PresetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new preset.
         * @summary Create a Preset
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreatePresetRequest} [createPresetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPreset: async (fields?: Array<string>, meta?: string, createPresetRequest?: CreatePresetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPresetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing preset.
         * @summary Delete a Preset
         * @param {number} id Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePreset: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePreset', 'id', id)
            const localVarPath = `/presets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing presets.
         * @summary Delete Multiple Presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePresets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single preset by unique identifier.
         * @summary Retrieve a Preset
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreset: async (id: number, fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPreset', 'id', id)
            const localVarPath = `/presets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the presets.
         * @summary List Presets
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresets: async (fields?: Array<string>, limit?: number, offset?: number, page?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing preset.
         * @summary Update a Preset
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdatePresetRequest} [updatePresetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreset: async (id: number, fields?: Array<string>, meta?: string, updatePresetRequest?: UpdatePresetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePreset', 'id', id)
            const localVarPath = `/presets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePresetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple presets at the same time.
         * @summary Update Multiple Presets
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdatePresetsRequest} [updatePresetsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePresets: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updatePresetsRequest?: UpdatePresetsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePresetsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PresetsApi - functional programming interface
 * @export
 */
export const PresetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PresetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new preset.
         * @summary Create a Preset
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreatePresetRequest} [createPresetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPreset(fields?: Array<string>, meta?: string, createPresetRequest?: CreatePresetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePreset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPreset(fields, meta, createPresetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresetsApi.createPreset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing preset.
         * @summary Delete a Preset
         * @param {number} id Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePreset(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePreset(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresetsApi.deletePreset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing presets.
         * @summary Delete Multiple Presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePresets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePresets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresetsApi.deletePresets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single preset by unique identifier.
         * @summary Retrieve a Preset
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreset(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePreset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreset(id, fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresetsApi.getPreset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the presets.
         * @summary List Presets
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresets(fields?: Array<string>, limit?: number, offset?: number, page?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPresets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresets(fields, limit, offset, page, sort, filter, search, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresetsApi.getPresets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing preset.
         * @summary Update a Preset
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdatePresetRequest} [updatePresetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePreset(id: number, fields?: Array<string>, meta?: string, updatePresetRequest?: UpdatePresetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePreset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePreset(id, fields, meta, updatePresetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresetsApi.updatePreset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple presets at the same time.
         * @summary Update Multiple Presets
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdatePresetsRequest} [updatePresetsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePresets(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updatePresetsRequest?: UpdatePresetsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPresets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePresets(fields, limit, meta, offset, sort, filter, search, updatePresetsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresetsApi.updatePresets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PresetsApi - factory interface
 * @export
 */
export const PresetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PresetsApiFp(configuration)
    return {
        /**
         * Create a new preset.
         * @summary Create a Preset
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreatePresetRequest} [createPresetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPreset(fields?: Array<string>, meta?: string, createPresetRequest?: CreatePresetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePreset200Response> {
            return localVarFp.createPreset(fields, meta, createPresetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing preset.
         * @summary Delete a Preset
         * @param {number} id Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePreset(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePreset(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing presets.
         * @summary Delete Multiple Presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePresets(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePresets(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single preset by unique identifier.
         * @summary Retrieve a Preset
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreset(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatePreset200Response> {
            return localVarFp.getPreset(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the presets.
         * @summary List Presets
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresets(fields?: Array<string>, limit?: number, offset?: number, page?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPresets200Response> {
            return localVarFp.getPresets(fields, limit, offset, page, sort, filter, search, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing preset.
         * @summary Update a Preset
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdatePresetRequest} [updatePresetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreset(id: number, fields?: Array<string>, meta?: string, updatePresetRequest?: UpdatePresetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePreset200Response> {
            return localVarFp.updatePreset(id, fields, meta, updatePresetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple presets at the same time.
         * @summary Update Multiple Presets
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdatePresetsRequest} [updatePresetsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePresets(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updatePresetsRequest?: UpdatePresetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetPresets200Response> {
            return localVarFp.updatePresets(fields, limit, meta, offset, sort, filter, search, updatePresetsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PresetsApi - object-oriented interface
 * @export
 * @class PresetsApi
 * @extends {BaseAPI}
 */
export class PresetsApi extends BaseAPI {
    /**
     * Create a new preset.
     * @summary Create a Preset
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreatePresetRequest} [createPresetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresetsApi
     */
    public createPreset(fields?: Array<string>, meta?: string, createPresetRequest?: CreatePresetRequest, options?: RawAxiosRequestConfig) {
        return PresetsApiFp(this.configuration).createPreset(fields, meta, createPresetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing preset.
     * @summary Delete a Preset
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresetsApi
     */
    public deletePreset(id: number, options?: RawAxiosRequestConfig) {
        return PresetsApiFp(this.configuration).deletePreset(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing presets.
     * @summary Delete Multiple Presets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresetsApi
     */
    public deletePresets(options?: RawAxiosRequestConfig) {
        return PresetsApiFp(this.configuration).deletePresets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single preset by unique identifier.
     * @summary Retrieve a Preset
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresetsApi
     */
    public getPreset(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return PresetsApiFp(this.configuration).getPreset(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the presets.
     * @summary List Presets
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresetsApi
     */
    public getPresets(fields?: Array<string>, limit?: number, offset?: number, page?: number, sort?: Array<string>, filter?: object, search?: string, meta?: string, options?: RawAxiosRequestConfig) {
        return PresetsApiFp(this.configuration).getPresets(fields, limit, offset, page, sort, filter, search, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing preset.
     * @summary Update a Preset
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {UpdatePresetRequest} [updatePresetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresetsApi
     */
    public updatePreset(id: number, fields?: Array<string>, meta?: string, updatePresetRequest?: UpdatePresetRequest, options?: RawAxiosRequestConfig) {
        return PresetsApiFp(this.configuration).updatePreset(id, fields, meta, updatePresetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple presets at the same time.
     * @summary Update Multiple Presets
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdatePresetsRequest} [updatePresetsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresetsApi
     */
    public updatePresets(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updatePresetsRequest?: UpdatePresetsRequest, options?: RawAxiosRequestConfig) {
        return PresetsApiFp(this.configuration).updatePresets(fields, limit, meta, offset, sort, filter, search, updatePresetsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RelationsApi - axios parameter creator
 * @export
 */
export const RelationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new relation.
         * @summary Create a Relation
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateRelationRequest} [createRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelation: async (fields?: Array<string>, meta?: string, createRelationRequest?: CreateRelationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRelationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing relation.
         * @summary Delete a Relation
         * @param {number} id Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelation: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRelation', 'id', id)
            const localVarPath = `/relations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single relation by unique identifier.
         * @summary Retrieve a Relation
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelation: async (id: number, fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRelation', 'id', id)
            const localVarPath = `/relations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the relations.
         * @summary List Relations
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelations: async (fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing relation
         * @summary Update a Relation
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateRelationRequest} [updateRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRelation: async (id: number, fields?: Array<string>, meta?: string, updateRelationRequest?: UpdateRelationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRelation', 'id', id)
            const localVarPath = `/relations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRelationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelationsApi - functional programming interface
 * @export
 */
export const RelationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new relation.
         * @summary Create a Relation
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateRelationRequest} [createRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRelation(fields?: Array<string>, meta?: string, createRelationRequest?: CreateRelationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRelation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRelation(fields, meta, createRelationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationsApi.createRelation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing relation.
         * @summary Delete a Relation
         * @param {number} id Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelation(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationsApi.deleteRelation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single relation by unique identifier.
         * @summary Retrieve a Relation
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelation(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRelation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelation(id, fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationsApi.getRelation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the relations.
         * @summary List Relations
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelations(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRelations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelations(fields, limit, offset, meta, sort, filter, search, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationsApi.getRelations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing relation
         * @summary Update a Relation
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateRelationRequest} [updateRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRelation(id: number, fields?: Array<string>, meta?: string, updateRelationRequest?: UpdateRelationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRelation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRelation(id, fields, meta, updateRelationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationsApi.updateRelation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RelationsApi - factory interface
 * @export
 */
export const RelationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelationsApiFp(configuration)
    return {
        /**
         * Create a new relation.
         * @summary Create a Relation
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateRelationRequest} [createRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelation(fields?: Array<string>, meta?: string, createRelationRequest?: CreateRelationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateRelation200Response> {
            return localVarFp.createRelation(fields, meta, createRelationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing relation.
         * @summary Delete a Relation
         * @param {number} id Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelation(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single relation by unique identifier.
         * @summary Retrieve a Relation
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelation(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateRelation200Response> {
            return localVarFp.getRelation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the relations.
         * @summary List Relations
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelations(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetRelations200Response> {
            return localVarFp.getRelations(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing relation
         * @summary Update a Relation
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateRelationRequest} [updateRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRelation(id: number, fields?: Array<string>, meta?: string, updateRelationRequest?: UpdateRelationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateRelation200Response> {
            return localVarFp.updateRelation(id, fields, meta, updateRelationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RelationsApi - object-oriented interface
 * @export
 * @class RelationsApi
 * @extends {BaseAPI}
 */
export class RelationsApi extends BaseAPI {
    /**
     * Create a new relation.
     * @summary Create a Relation
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateRelationRequest} [createRelationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public createRelation(fields?: Array<string>, meta?: string, createRelationRequest?: CreateRelationRequest, options?: RawAxiosRequestConfig) {
        return RelationsApiFp(this.configuration).createRelation(fields, meta, createRelationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing relation.
     * @summary Delete a Relation
     * @param {number} id Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public deleteRelation(id: number, options?: RawAxiosRequestConfig) {
        return RelationsApiFp(this.configuration).deleteRelation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single relation by unique identifier.
     * @summary Retrieve a Relation
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public getRelation(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return RelationsApiFp(this.configuration).getRelation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the relations.
     * @summary List Relations
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public getRelations(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig) {
        return RelationsApiFp(this.configuration).getRelations(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing relation
     * @summary Update a Relation
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {UpdateRelationRequest} [updateRelationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public updateRelation(id: number, fields?: Array<string>, meta?: string, updateRelationRequest?: UpdateRelationRequest, options?: RawAxiosRequestConfig) {
        return RelationsApiFp(this.configuration).updateRelation(id, fields, meta, updateRelationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RevisionsApi - axios parameter creator
 * @export
 */
export const RevisionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a single revision by unique identifier.
         * @summary Retrieve a Revision
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevision: async (id: number, fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRevision', 'id', id)
            const localVarPath = `/revisions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the revisions.
         * @summary List Revisions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevisions: async (fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/revisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RevisionsApi - functional programming interface
 * @export
 */
export const RevisionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RevisionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a single revision by unique identifier.
         * @summary Retrieve a Revision
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRevision(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRevision200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRevision(id, fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevisionsApi.getRevision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the revisions.
         * @summary List Revisions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRevisions(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRevisions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRevisions(fields, limit, offset, meta, sort, filter, search, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevisionsApi.getRevisions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RevisionsApi - factory interface
 * @export
 */
export const RevisionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RevisionsApiFp(configuration)
    return {
        /**
         * Retrieve a single revision by unique identifier.
         * @summary Retrieve a Revision
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevision(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRevision200Response> {
            return localVarFp.getRevision(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the revisions.
         * @summary List Revisions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevisions(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetRevisions200Response> {
            return localVarFp.getRevisions(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RevisionsApi - object-oriented interface
 * @export
 * @class RevisionsApi
 * @extends {BaseAPI}
 */
export class RevisionsApi extends BaseAPI {
    /**
     * Retrieve a single revision by unique identifier.
     * @summary Retrieve a Revision
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevisionsApi
     */
    public getRevision(id: number, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return RevisionsApiFp(this.configuration).getRevision(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the revisions.
     * @summary List Revisions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevisionsApi
     */
    public getRevisions(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig) {
        return RevisionsApiFp(this.configuration).getRevisions(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new role.
         * @summary Create a Role
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateRoleRequest} [createRoleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (fields?: Array<string>, meta?: string, createRoleRequest?: CreateRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing role
         * @summary Delete a Role
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing roles.
         * @summary Delete Multiple Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single role by unique identifier.
         * @summary Retrieve a Role
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (id: string, fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the roles.
         * @summary List Roles
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles: async (fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing role
         * @summary Update a Role
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateRoleRequest} [updateRoleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (id: string, fields?: Array<string>, meta?: string, updateRoleRequest?: UpdateRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple roles at the same time.
         * @summary Update Multiple Roles
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateRolesRequest} [updateRolesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoles: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateRolesRequest?: UpdateRolesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRolesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new role.
         * @summary Create a Role
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateRoleRequest} [createRoleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(fields?: Array<string>, meta?: string, createRoleRequest?: CreateRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(fields, meta, createRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.createRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing role
         * @summary Delete a Role
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.deleteRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing roles.
         * @summary Delete Multiple Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.deleteRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single role by unique identifier.
         * @summary Retrieve a Role
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(id, fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the roles.
         * @summary List Roles
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoles(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRoles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoles(fields, limit, offset, meta, sort, filter, search, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing role
         * @summary Update a Role
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateRoleRequest} [updateRoleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(id: string, fields?: Array<string>, meta?: string, updateRoleRequest?: UpdateRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(id, fields, meta, updateRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.updateRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple roles at the same time.
         * @summary Update Multiple Roles
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateRolesRequest} [updateRolesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateRolesRequest?: UpdateRolesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRoles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoles(fields, limit, meta, offset, sort, filter, search, updateRolesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.updateRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * Create a new role.
         * @summary Create a Role
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateRoleRequest} [createRoleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(fields?: Array<string>, meta?: string, createRoleRequest?: CreateRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateRole200Response> {
            return localVarFp.createRole(fields, meta, createRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing role
         * @summary Delete a Role
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing roles.
         * @summary Delete Multiple Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoles(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single role by unique identifier.
         * @summary Retrieve a Role
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateRole200Response> {
            return localVarFp.getRole(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the roles.
         * @summary List Roles
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetRoles200Response> {
            return localVarFp.getRoles(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing role
         * @summary Update a Role
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {UpdateRoleRequest} [updateRoleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(id: string, fields?: Array<string>, meta?: string, updateRoleRequest?: UpdateRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateRole200Response> {
            return localVarFp.updateRole(id, fields, meta, updateRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple roles at the same time.
         * @summary Update Multiple Roles
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateRolesRequest} [updateRolesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateRolesRequest?: UpdateRolesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetRoles200Response> {
            return localVarFp.updateRoles(fields, limit, meta, offset, sort, filter, search, updateRolesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * Create a new role.
     * @summary Create a Role
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateRoleRequest} [createRoleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRole(fields?: Array<string>, meta?: string, createRoleRequest?: CreateRoleRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRole(fields, meta, createRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing role
     * @summary Delete a Role
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRole(id: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing roles.
     * @summary Delete Multiple Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRoles(options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single role by unique identifier.
     * @summary Retrieve a Role
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRole(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRole(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the roles.
     * @summary List Roles
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoles(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, page?: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRoles(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing role
     * @summary Update a Role
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {UpdateRoleRequest} [updateRoleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public updateRole(id: string, fields?: Array<string>, meta?: string, updateRoleRequest?: UpdateRoleRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).updateRole(id, fields, meta, updateRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple roles at the same time.
     * @summary Update Multiple Roles
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdateRolesRequest} [updateRolesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public updateRoles(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateRolesRequest?: UpdateRolesRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).updateRoles(fields, limit, meta, offset, sort, filter, search, updateRolesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the instance\'s schema by passing the diff previously retrieved via `/schema/diff` endpoint in the JSON request body or a JSON/YAML file. This endpoint is only available to admin users.
         * @summary Apply Schema Difference
         * @param {SchemaApplyRequest} schemaApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaApply: async (schemaApplyRequest: SchemaApplyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schemaApplyRequest' is not null or undefined
            assertParamExists('schemaApply', 'schemaApplyRequest', schemaApplyRequest)
            const localVarPath = `/schema/apply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaApplyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compare the current instance\'s schema against the schema snapshot in JSON request body or a JSON/YAML file and retrieve the difference. This endpoint is only available to admin users.
         * @summary Retrieve Schema Difference
         * @param {SchemaSnapshot200Response} schemaSnapshot200Response 
         * @param {boolean} [force] Bypass version and database vendor restrictions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaDiff: async (schemaSnapshot200Response: SchemaSnapshot200Response, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schemaSnapshot200Response' is not null or undefined
            assertParamExists('schemaDiff', 'schemaSnapshot200Response', schemaSnapshot200Response)
            const localVarPath = `/schema/diff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaSnapshot200Response, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current schema. This endpoint is only available to admin users.
         * @summary Retrieve Schema Snapshot
         * @param {SchemaSnapshotExportEnum} [_export] Saves the API response to a file. Accepts one of \&quot;csv\&quot;, \&quot;json\&quot;, \&quot;xml\&quot;, \&quot;yaml\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaSnapshot: async (_export?: SchemaSnapshotExportEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schema/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_export !== undefined) {
                localVarQueryParameter['export'] = _export;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the instance\'s schema by passing the diff previously retrieved via `/schema/diff` endpoint in the JSON request body or a JSON/YAML file. This endpoint is only available to admin users.
         * @summary Apply Schema Difference
         * @param {SchemaApplyRequest} schemaApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaApply(schemaApplyRequest: SchemaApplyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaApply(schemaApplyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemaApi.schemaApply']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Compare the current instance\'s schema against the schema snapshot in JSON request body or a JSON/YAML file and retrieve the difference. This endpoint is only available to admin users.
         * @summary Retrieve Schema Difference
         * @param {SchemaSnapshot200Response} schemaSnapshot200Response 
         * @param {boolean} [force] Bypass version and database vendor restrictions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaDiff(schemaSnapshot200Response: SchemaSnapshot200Response, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaApplyRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaDiff(schemaSnapshot200Response, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemaApi.schemaDiff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current schema. This endpoint is only available to admin users.
         * @summary Retrieve Schema Snapshot
         * @param {SchemaSnapshotExportEnum} [_export] Saves the API response to a file. Accepts one of \&quot;csv\&quot;, \&quot;json\&quot;, \&quot;xml\&quot;, \&quot;yaml\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaSnapshot(_export?: SchemaSnapshotExportEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaSnapshot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaSnapshot(_export, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemaApi.schemaSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * Update the instance\'s schema by passing the diff previously retrieved via `/schema/diff` endpoint in the JSON request body or a JSON/YAML file. This endpoint is only available to admin users.
         * @summary Apply Schema Difference
         * @param {SchemaApplyRequest} schemaApplyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaApply(schemaApplyRequest: SchemaApplyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.schemaApply(schemaApplyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Compare the current instance\'s schema against the schema snapshot in JSON request body or a JSON/YAML file and retrieve the difference. This endpoint is only available to admin users.
         * @summary Retrieve Schema Difference
         * @param {SchemaSnapshot200Response} schemaSnapshot200Response 
         * @param {boolean} [force] Bypass version and database vendor restrictions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaDiff(schemaSnapshot200Response: SchemaSnapshot200Response, force?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SchemaApplyRequest> {
            return localVarFp.schemaDiff(schemaSnapshot200Response, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current schema. This endpoint is only available to admin users.
         * @summary Retrieve Schema Snapshot
         * @param {SchemaSnapshotExportEnum} [_export] Saves the API response to a file. Accepts one of \&quot;csv\&quot;, \&quot;json\&quot;, \&quot;xml\&quot;, \&quot;yaml\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaSnapshot(_export?: SchemaSnapshotExportEnum, options?: RawAxiosRequestConfig): AxiosPromise<SchemaSnapshot200Response> {
            return localVarFp.schemaSnapshot(_export, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * Update the instance\'s schema by passing the diff previously retrieved via `/schema/diff` endpoint in the JSON request body or a JSON/YAML file. This endpoint is only available to admin users.
     * @summary Apply Schema Difference
     * @param {SchemaApplyRequest} schemaApplyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaApply(schemaApplyRequest: SchemaApplyRequest, options?: RawAxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaApply(schemaApplyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Compare the current instance\'s schema against the schema snapshot in JSON request body or a JSON/YAML file and retrieve the difference. This endpoint is only available to admin users.
     * @summary Retrieve Schema Difference
     * @param {SchemaSnapshot200Response} schemaSnapshot200Response 
     * @param {boolean} [force] Bypass version and database vendor restrictions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaDiff(schemaSnapshot200Response: SchemaSnapshot200Response, force?: boolean, options?: RawAxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaDiff(schemaSnapshot200Response, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the current schema. This endpoint is only available to admin users.
     * @summary Retrieve Schema Snapshot
     * @param {SchemaSnapshotExportEnum} [_export] Saves the API response to a file. Accepts one of \&quot;csv\&quot;, \&quot;json\&quot;, \&quot;xml\&quot;, \&quot;yaml\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaSnapshot(_export?: SchemaSnapshotExportEnum, options?: RawAxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaSnapshot(_export, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SchemaSnapshotExportEnum = {
    Csv: 'csv',
    Json: 'json',
    Xml: 'xml',
    Yaml: 'yaml'
} as const;
export type SchemaSnapshotExportEnum = typeof SchemaSnapshotExportEnum[keyof typeof SchemaSnapshotExportEnum];


/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Ping, pong. Ping.. pong.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a system status check and return the options.
         * @summary System Info
         * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverInfo: async (superAdminToken: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'superAdminToken' is not null or undefined
            assertParamExists('serverInfo', 'superAdminToken', superAdminToken)
            const localVarPath = `/server/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (superAdminToken !== undefined) {
                localVarQueryParameter['super_admin_token'] = superAdminToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
    return {
        /**
         * Ping, pong. Ping.. pong.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform a system status check and return the options.
         * @summary System Info
         * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverInfo(superAdminToken: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serverInfo(superAdminToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerApi.serverInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerApiFp(configuration)
    return {
        /**
         * Ping, pong. Ping.. pong.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a system status check and return the options.
         * @summary System Info
         * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverInfo(superAdminToken: number, options?: RawAxiosRequestConfig): AxiosPromise<ServerInfo200Response> {
            return localVarFp.serverInfo(superAdminToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * Ping, pong. Ping.. pong.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return ServerApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a system status check and return the options.
     * @summary System Info
     * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverInfo(superAdminToken: number, options?: RawAxiosRequestConfig) {
        return ServerApiFp(this.configuration).serverInfo(superAdminToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the settings.
         * @summary Retrieve Settings
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (limit?: number, offset?: number, meta?: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the settings
         * @summary Update Settings
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting: async (body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * List the settings.
         * @summary Retrieve Settings
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(limit?: number, offset?: number, meta?: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(limit, offset, meta, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.getSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the settings
         * @summary Update Settings
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSetting(body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSettings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSetting(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.updateSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * List the settings.
         * @summary Retrieve Settings
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(limit?: number, offset?: number, meta?: string, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetSettings200Response> {
            return localVarFp.getSettings(limit, offset, meta, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the settings
         * @summary Update Settings
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(body?: object, options?: RawAxiosRequestConfig): AxiosPromise<GetSettings200Response> {
            return localVarFp.updateSetting(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * List the settings.
     * @summary Retrieve Settings
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSettings(limit?: number, offset?: number, meta?: string, page?: number, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getSettings(limit, offset, meta, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the settings
     * @summary Update Settings
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateSetting(body?: object, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updateSetting(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accepts and enables an invited user using a JWT invitation token.
         * @summary Accept User Invite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (acceptInviteRequest: AcceptInviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptInviteRequest' is not null or undefined
            assertParamExists('acceptInvite', 'acceptInviteRequest', acceptInviteRequest)
            const localVarPath = `/users/invite/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(acceptInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user.
         * @summary Create a User
         * @param {string} [meta] What metadata to return in the response.
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (meta?: string, users?: Users, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(users, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing user
         * @summary Delete a User
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing users.
         * @summary Delete Multiple Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the currently authenticated user.
         * @summary Retrieve Current User
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single user by unique identifier.
         * @summary Retrieve a User
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the users.
         * @summary List Users
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account.
         * @summary Invite User(s)
         * @param {InviteRequest} [inviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invite: async (inviteRequest?: InviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables two-factor authentication for the currently authenticated user.
         * @summary Disable 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meTfaDisable: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/tfa/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables two-factor authentication for the currently authenticated user.
         * @summary Enable 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meTfaEnable: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/tfa/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used.
         * @summary Update Last Page
         * @param {UpdateLastUsedPageMeRequest} [updateLastUsedPageMeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLastUsedPageMe: async (updateLastUsedPageMeRequest?: UpdateLastUsedPageMeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/track/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLastUsedPageMeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the currently authenticated user.
         * @summary Update Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing user
         * @summary Update a User
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, fields?: Array<string>, meta?: string, users?: Users, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(users, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple users at the same time.
         * @summary Update Multiple Users
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateUsersRequest} [updateUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsers: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateUsersRequest?: UpdateUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Accepts and enables an invited user using a JWT invitation token.
         * @summary Accept User Invite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(acceptInviteRequest: AcceptInviteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(acceptInviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.acceptInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user.
         * @summary Create a User
         * @param {string} [meta] What metadata to return in the response.
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(meta?: string, users?: Users, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(meta, users, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing user
         * @summary Delete a User
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing users.
         * @summary Delete Multiple Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the currently authenticated user.
         * @summary Retrieve Current User
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single user by unique identifier.
         * @summary Retrieve a User
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the users.
         * @summary List Users
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(fields, limit, offset, meta, sort, filter, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account.
         * @summary Invite User(s)
         * @param {InviteRequest} [inviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invite(inviteRequest?: InviteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invite(inviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.invite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disables two-factor authentication for the currently authenticated user.
         * @summary Disable 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meTfaDisable(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meTfaDisable(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.meTfaDisable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enables two-factor authentication for the currently authenticated user.
         * @summary Enable 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meTfaEnable(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meTfaEnable(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.meTfaEnable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used.
         * @summary Update Last Page
         * @param {UpdateLastUsedPageMeRequest} [updateLastUsedPageMeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLastUsedPageMe(updateLastUsedPageMeRequest?: UpdateLastUsedPageMeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLastUsedPageMe(updateLastUsedPageMeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateLastUsedPageMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the currently authenticated user.
         * @summary Update Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing user
         * @summary Update a User
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, fields?: Array<string>, meta?: string, users?: Users, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, fields, meta, users, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple users at the same time.
         * @summary Update Multiple Users
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateUsersRequest} [updateUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateUsersRequest?: UpdateUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsers(fields, limit, meta, offset, sort, filter, search, updateUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Accepts and enables an invited user using a JWT invitation token.
         * @summary Accept User Invite
         * @param {AcceptInviteRequest} acceptInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(acceptInviteRequest: AcceptInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateUser200Response> {
            return localVarFp.acceptInvite(acceptInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.
         * @summary Create a User
         * @param {string} [meta] What metadata to return in the response.
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(meta?: string, users?: Users, options?: RawAxiosRequestConfig): AxiosPromise<CreateUser200Response> {
            return localVarFp.createUser(meta, users, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing user
         * @summary Delete a User
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing users.
         * @summary Delete Multiple Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsers(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the currently authenticated user.
         * @summary Retrieve Current User
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateUser200Response> {
            return localVarFp.getMe(fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single user by unique identifier.
         * @summary Retrieve a User
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateUser200Response> {
            return localVarFp.getUser(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the users.
         * @summary List Users
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUsers200Response> {
            return localVarFp.getUsers(fields, limit, offset, meta, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account.
         * @summary Invite User(s)
         * @param {InviteRequest} [inviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invite(inviteRequest?: InviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateUser200Response> {
            return localVarFp.invite(inviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables two-factor authentication for the currently authenticated user.
         * @summary Disable 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meTfaDisable(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.meTfaDisable(options).then((request) => request(axios, basePath));
        },
        /**
         * Enables two-factor authentication for the currently authenticated user.
         * @summary Enable 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meTfaEnable(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.meTfaEnable(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used.
         * @summary Update Last Page
         * @param {UpdateLastUsedPageMeRequest} [updateLastUsedPageMeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLastUsedPageMe(updateLastUsedPageMeRequest?: UpdateLastUsedPageMeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateLastUsedPageMe(updateLastUsedPageMeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the currently authenticated user.
         * @summary Update Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMe(options?: RawAxiosRequestConfig): AxiosPromise<CreateUser200Response> {
            return localVarFp.updateMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing user
         * @summary Update a User
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Users} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, fields?: Array<string>, meta?: string, users?: Users, options?: RawAxiosRequestConfig): AxiosPromise<ServerInfo200Response> {
            return localVarFp.updateUser(id, fields, meta, users, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple users at the same time.
         * @summary Update Multiple Users
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateUsersRequest} [updateUsersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateUsersRequest?: UpdateUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetUsers200Response> {
            return localVarFp.updateUsers(fields, limit, meta, offset, sort, filter, search, updateUsersRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Accepts and enables an invited user using a JWT invitation token.
     * @summary Accept User Invite
     * @param {AcceptInviteRequest} acceptInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public acceptInvite(acceptInviteRequest: AcceptInviteRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).acceptInvite(acceptInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user.
     * @summary Create a User
     * @param {string} [meta] What metadata to return in the response.
     * @param {Users} [users] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(meta?: string, users?: Users, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(meta, users, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing user
     * @summary Delete a User
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing users.
     * @summary Delete Multiple Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUsers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the currently authenticated user.
     * @summary Retrieve Current User
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMe(fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMe(fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single user by unique identifier.
     * @summary Retrieve a User
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the users.
     * @summary List Users
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(fields, limit, offset, meta, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account.
     * @summary Invite User(s)
     * @param {InviteRequest} [inviteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public invite(inviteRequest?: InviteRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).invite(inviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables two-factor authentication for the currently authenticated user.
     * @summary Disable 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public meTfaDisable(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).meTfaDisable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables two-factor authentication for the currently authenticated user.
     * @summary Enable 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public meTfaEnable(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).meTfaEnable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used.
     * @summary Update Last Page
     * @param {UpdateLastUsedPageMeRequest} [updateLastUsedPageMeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateLastUsedPageMe(updateLastUsedPageMeRequest?: UpdateLastUsedPageMeRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateLastUsedPageMe(updateLastUsedPageMeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the currently authenticated user.
     * @summary Update Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateMe(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing user
     * @summary Update a User
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Users} [users] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: string, fields?: Array<string>, meta?: string, users?: Users, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(id, fields, meta, users, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple users at the same time.
     * @summary Update Multiple Users
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdateUsersRequest} [updateUsersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUsers(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateUsersRequest?: UpdateUsersRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUsers(fields, limit, meta, offset, sort, filter, search, updateUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UtilitiesApi - axios parameter creator
 * @export
 */
export const UtilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export a larger data set to a file in the File Library
         * @summary Export Items
         * @param {string} collection Collection identifier
         * @param {ExportRequest} [exportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (collection: string, exportRequest?: ExportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('_export', 'collection', collection)
            const localVarPath = `/utils/export/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import multiple records from a JSON or CSV file into a collection.
         * @summary Import Items
         * @param {string} collection Collection identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _import: async (collection: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('_import', 'collection', collection)
            const localVarPath = `/utils/import/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets both the data and schema cache of Directus.
         * @summary Clear Cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCache: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/utils/cache/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashGenerateRequest} [hashGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashGenerate: async (hashGenerateRequest?: HashGenerateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/utils/hash/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hashGenerateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashVerifyRequest} [hashVerifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashVerify: async (hashVerifyRequest?: HashVerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/utils/hash/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hashVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a random string of given length.
         * @summary Get a Random String
         * @param {number} [length] Length of the random string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        random: async (length?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/utils/random/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-sort items in collection based on start and to value of item
         * @summary Sort Items
         * @param {string} collection Collection identifier
         * @param {SortRequest} [sortRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sort: async (collection: string, sortRequest?: SortRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('sort', 'collection', collection)
            const localVarPath = `/utils/sort/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sortRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilitiesApi - functional programming interface
 * @export
 */
export const UtilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Export a larger data set to a file in the File Library
         * @summary Export Items
         * @param {string} collection Collection identifier
         * @param {ExportRequest} [exportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(collection: string, exportRequest?: ExportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(collection, exportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi._export']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import multiple records from a JSON or CSV file into a collection.
         * @summary Import Items
         * @param {string} collection Collection identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _import(collection: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._import(collection, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi._import']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets both the data and schema cache of Directus.
         * @summary Clear Cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearCache(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearCache(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi.clearCache']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashGenerateRequest} [hashGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashGenerate(hashGenerateRequest?: HashGenerateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashGenerate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashGenerate(hashGenerateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi.hashGenerate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashVerifyRequest} [hashVerifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashVerify(hashVerifyRequest?: HashVerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashVerify200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashVerify(hashVerifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi.hashVerify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a random string of given length.
         * @summary Get a Random String
         * @param {number} [length] Length of the random string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async random(length?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Random200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.random(length, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi.random']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Re-sort items in collection based on start and to value of item
         * @summary Sort Items
         * @param {string} collection Collection identifier
         * @param {SortRequest} [sortRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sort(collection: string, sortRequest?: SortRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sort(collection, sortRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi.sort']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UtilitiesApi - factory interface
 * @export
 */
export const UtilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilitiesApiFp(configuration)
    return {
        /**
         * Export a larger data set to a file in the File Library
         * @summary Export Items
         * @param {string} collection Collection identifier
         * @param {ExportRequest} [exportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(collection: string, exportRequest?: ExportRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._export(collection, exportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import multiple records from a JSON or CSV file into a collection.
         * @summary Import Items
         * @param {string} collection Collection identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _import(collection: string, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._import(collection, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets both the data and schema cache of Directus.
         * @summary Clear Cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCache(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clearCache(options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashGenerateRequest} [hashGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashGenerate(hashGenerateRequest?: HashGenerateRequest, options?: RawAxiosRequestConfig): AxiosPromise<HashGenerate200Response> {
            return localVarFp.hashGenerate(hashGenerateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashVerifyRequest} [hashVerifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashVerify(hashVerifyRequest?: HashVerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<HashVerify200Response> {
            return localVarFp.hashVerify(hashVerifyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a random string of given length.
         * @summary Get a Random String
         * @param {number} [length] Length of the random string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        random(length?: number, options?: RawAxiosRequestConfig): AxiosPromise<Random200Response> {
            return localVarFp.random(length, options).then((request) => request(axios, basePath));
        },
        /**
         * Re-sort items in collection based on start and to value of item
         * @summary Sort Items
         * @param {string} collection Collection identifier
         * @param {SortRequest} [sortRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sort(collection: string, sortRequest?: SortRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sort(collection, sortRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilitiesApi - object-oriented interface
 * @export
 * @class UtilitiesApi
 * @extends {BaseAPI}
 */
export class UtilitiesApi extends BaseAPI {
    /**
     * Export a larger data set to a file in the File Library
     * @summary Export Items
     * @param {string} collection Collection identifier
     * @param {ExportRequest} [exportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public _export(collection: string, exportRequest?: ExportRequest, options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration)._export(collection, exportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import multiple records from a JSON or CSV file into a collection.
     * @summary Import Items
     * @param {string} collection Collection identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public _import(collection: string, file?: File, options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration)._import(collection, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets both the data and schema cache of Directus.
     * @summary Clear Cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public clearCache(options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).clearCache(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a hash for a given string.
     * @summary Hash a string
     * @param {HashGenerateRequest} [hashGenerateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public hashGenerate(hashGenerateRequest?: HashGenerateRequest, options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).hashGenerate(hashGenerateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a hash for a given string.
     * @summary Hash a string
     * @param {HashVerifyRequest} [hashVerifyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public hashVerify(hashVerifyRequest?: HashVerifyRequest, options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).hashVerify(hashVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a random string of given length.
     * @summary Get a Random String
     * @param {number} [length] Length of the random string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public random(length?: number, options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).random(length, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Re-sort items in collection based on start and to value of item
     * @summary Sort Items
     * @param {string} collection Collection identifier
     * @param {SortRequest} [sortRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public sort(collection: string, sortRequest?: SortRequest, options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).sort(collection, sortRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VersionsApi - axios parameter creator
 * @export
 */
export const VersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Compare an existing Content Version with the main version of the item.
         * @summary Compare a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareContentVersion: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('compareContentVersion', 'id', id)
            const localVarPath = `/versions/{id}/compare`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create multiple new Content Versions.
         * @summary Create Multiple Content Versions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Versions} [versions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContentVersion: async (fields?: Array<string>, meta?: string, versions?: Versions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(versions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Content Version.
         * @summary Delete a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentVersion: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteContentVersion', 'id', id)
            const localVarPath = `/versions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing Content Versions.
         * @summary Delete Multiple Content Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentVersions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Content Version by unique identifier.
         * @summary Retrieve a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentVersion: async (id: string, fields?: Array<string>, meta?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContentVersion', 'id', id)
            const localVarPath = `/versions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Content Versions.
         * @summary List Content Versions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentVersions: async (fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pass the current hash of the main version of the item (obtained from the `compare` endpoint) along with an optional array of field names of which the values are to be promoted (by default, all fields are selected).
         * @summary Promote a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {PromoteContentVersionRequest} [promoteContentVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteContentVersion: async (id: string, promoteContentVersionRequest?: PromoteContentVersionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('promoteContentVersion', 'id', id)
            const localVarPath = `/versions/{id}/promote`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promoteContentVersionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save item changes to an existing Content Version.
         * @summary Save to a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveContentVersion: async (id: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('saveContentVersion', 'id', id)
            const localVarPath = `/versions/{id}/save`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Content Version.
         * @summary Update a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Versions} [versions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentVersion: async (id: string, fields?: Array<string>, meta?: string, versions?: Versions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateContentVersion', 'id', id)
            const localVarPath = `/versions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(versions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple Content Versions at the same time.
         * @summary Update Multiple Content Versions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateContentVersionsRequest} [updateContentVersionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentVersions: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateContentVersionsRequest?: UpdateContentVersionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContentVersionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsApi - functional programming interface
 * @export
 */
export const VersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Compare an existing Content Version with the main version of the item.
         * @summary Compare a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compareContentVersion(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compareContentVersion(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.compareContentVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create multiple new Content Versions.
         * @summary Create Multiple Content Versions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Versions} [versions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContentVersion(fields?: Array<string>, meta?: string, versions?: Versions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContentVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContentVersion(fields, meta, versions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.createContentVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing Content Version.
         * @summary Delete a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContentVersion(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContentVersion(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.deleteContentVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing Content Versions.
         * @summary Delete Multiple Content Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContentVersions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContentVersions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.deleteContentVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single Content Version by unique identifier.
         * @summary Retrieve a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentVersion(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContentVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentVersion(id, fields, meta, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.getContentVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all Content Versions.
         * @summary List Content Versions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentVersions(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContentVersions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentVersions(fields, limit, offset, meta, sort, filter, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.getContentVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pass the current hash of the main version of the item (obtained from the `compare` endpoint) along with an optional array of field names of which the values are to be promoted (by default, all fields are selected).
         * @summary Promote a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {PromoteContentVersionRequest} [promoteContentVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoteContentVersion(id: string, promoteContentVersionRequest?: PromoteContentVersionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoteContentVersion(id, promoteContentVersionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.promoteContentVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Save item changes to an existing Content Version.
         * @summary Save to a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveContentVersion(id: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveContentVersion(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.saveContentVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing Content Version.
         * @summary Update a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Versions} [versions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContentVersion(id: string, fields?: Array<string>, meta?: string, versions?: Versions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContentVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContentVersion(id, fields, meta, versions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.updateContentVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple Content Versions at the same time.
         * @summary Update Multiple Content Versions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateContentVersionsRequest} [updateContentVersionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContentVersions(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateContentVersionsRequest?: UpdateContentVersionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContentVersions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContentVersions(fields, limit, meta, offset, sort, filter, search, updateContentVersionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.updateContentVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VersionsApi - factory interface
 * @export
 */
export const VersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionsApiFp(configuration)
    return {
        /**
         * Compare an existing Content Version with the main version of the item.
         * @summary Compare a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareContentVersion(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerInfo200Response> {
            return localVarFp.compareContentVersion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create multiple new Content Versions.
         * @summary Create Multiple Content Versions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Versions} [versions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContentVersion(fields?: Array<string>, meta?: string, versions?: Versions, options?: RawAxiosRequestConfig): AxiosPromise<CreateContentVersion200Response> {
            return localVarFp.createContentVersion(fields, meta, versions, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Content Version.
         * @summary Delete a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentVersion(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContentVersion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing Content Versions.
         * @summary Delete Multiple Content Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentVersions(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContentVersions(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Content Version by unique identifier.
         * @summary Retrieve a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentVersion(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateContentVersion200Response> {
            return localVarFp.getContentVersion(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all Content Versions.
         * @summary List Content Versions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentVersions(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetContentVersions200Response> {
            return localVarFp.getContentVersions(fields, limit, offset, meta, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Pass the current hash of the main version of the item (obtained from the `compare` endpoint) along with an optional array of field names of which the values are to be promoted (by default, all fields are selected).
         * @summary Promote a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {PromoteContentVersionRequest} [promoteContentVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteContentVersion(id: string, promoteContentVersionRequest?: PromoteContentVersionRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.promoteContentVersion(id, promoteContentVersionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Save item changes to an existing Content Version.
         * @summary Save to a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveContentVersion(id: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.saveContentVersion(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Content Version.
         * @summary Update a Content Version
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Versions} [versions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentVersion(id: string, fields?: Array<string>, meta?: string, versions?: Versions, options?: RawAxiosRequestConfig): AxiosPromise<CreateContentVersion200Response> {
            return localVarFp.updateContentVersion(id, fields, meta, versions, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple Content Versions at the same time.
         * @summary Update Multiple Content Versions
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateContentVersionsRequest} [updateContentVersionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentVersions(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateContentVersionsRequest?: UpdateContentVersionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetContentVersions200Response> {
            return localVarFp.updateContentVersions(fields, limit, meta, offset, sort, filter, search, updateContentVersionsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionsApi - object-oriented interface
 * @export
 * @class VersionsApi
 * @extends {BaseAPI}
 */
export class VersionsApi extends BaseAPI {
    /**
     * Compare an existing Content Version with the main version of the item.
     * @summary Compare a Content Version
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public compareContentVersion(id: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).compareContentVersion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create multiple new Content Versions.
     * @summary Create Multiple Content Versions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Versions} [versions] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public createContentVersion(fields?: Array<string>, meta?: string, versions?: Versions, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).createContentVersion(fields, meta, versions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Content Version.
     * @summary Delete a Content Version
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public deleteContentVersion(id: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).deleteContentVersion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing Content Versions.
     * @summary Delete Multiple Content Versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public deleteContentVersions(options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).deleteContentVersions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Content Version by unique identifier.
     * @summary Retrieve a Content Version
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getContentVersion(id: string, fields?: Array<string>, meta?: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getContentVersion(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all Content Versions.
     * @summary List Content Versions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getContentVersions(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: object, search?: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getContentVersions(fields, limit, offset, meta, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pass the current hash of the main version of the item (obtained from the `compare` endpoint) along with an optional array of field names of which the values are to be promoted (by default, all fields are selected).
     * @summary Promote a Content Version
     * @param {string} id Unique identifier for the object.
     * @param {PromoteContentVersionRequest} [promoteContentVersionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public promoteContentVersion(id: string, promoteContentVersionRequest?: PromoteContentVersionRequest, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).promoteContentVersion(id, promoteContentVersionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Save item changes to an existing Content Version.
     * @summary Save to a Content Version
     * @param {string} id Unique identifier for the object.
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public saveContentVersion(id: string, body?: object, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).saveContentVersion(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Content Version.
     * @summary Update a Content Version
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Versions} [versions] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public updateContentVersion(id: string, fields?: Array<string>, meta?: string, versions?: Versions, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).updateContentVersion(id, fields, meta, versions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple Content Versions at the same time.
     * @summary Update Multiple Content Versions
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdateContentVersionsRequest} [updateContentVersionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public updateContentVersions(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateContentVersionsRequest?: UpdateContentVersionsRequest, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).updateContentVersions(fields, limit, meta, offset, sort, filter, search, updateContentVersionsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook.
         * @summary Create a Webhook
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (fields?: Array<string>, meta?: string, createWebhookRequest?: CreateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing webhook
         * @summary Delete a Webhook
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhook', 'id', id)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple existing webhooks.
         * @summary Delete Multiple Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single webhook by unique identifier.
         * @summary Retrieve a Webhook
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhook', 'id', id)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all webhooks.
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing webhook
         * @summary Update a Webhook
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (id: string, fields?: Array<string>, meta?: string, createWebhookRequest?: CreateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWebhook', 'id', id)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple webhooks at the same time.
         * @summary Update Multiple Webhooks
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateWebhooksRequest} [updateWebhooksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhooks: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateWebhooksRequest?: UpdateWebhooksRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhooksRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a Webhook
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(fields?: Array<string>, meta?: string, createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(fields, meta, createWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an existing webhook
         * @summary Delete a Webhook
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple existing webhooks.
         * @summary Delete Multiple Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhooks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single webhook by unique identifier.
         * @summary Retrieve a Webhook
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWebhooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all webhooks.
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWebhooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing webhook
         * @summary Update a Webhook
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(id: string, fields?: Array<string>, meta?: string, createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(id, fields, meta, createWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple webhooks at the same time.
         * @summary Update Multiple Webhooks
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateWebhooksRequest} [updateWebhooksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhooks(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateWebhooksRequest?: UpdateWebhooksRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateWebhooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhooks(fields, limit, meta, offset, sort, filter, search, updateWebhooksRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.updateWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a Webhook
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(fields?: Array<string>, meta?: string, createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateRole200Response> {
            return localVarFp.createWebhook(fields, meta, createWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing webhook
         * @summary Delete a Webhook
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple existing webhooks.
         * @summary Delete Multiple Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhooks(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single webhook by unique identifier.
         * @summary Retrieve a Webhook
         * @param {string} id Unique identifier for the object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetWebhooks200Response> {
            return localVarFp.getWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all webhooks.
         * @summary List Webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options?: RawAxiosRequestConfig): AxiosPromise<GetWebhooks200Response> {
            return localVarFp.getWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing webhook
         * @summary Update a Webhook
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateWebhookRequest} [createWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(id: string, fields?: Array<string>, meta?: string, createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateRole200Response> {
            return localVarFp.updateWebhook(id, fields, meta, createWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple webhooks at the same time.
         * @summary Update Multiple Webhooks
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {object} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {UpdateWebhooksRequest} [updateWebhooksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhooks(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateWebhooksRequest?: UpdateWebhooksRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateWebhooks200Response> {
            return localVarFp.updateWebhooks(fields, limit, meta, offset, sort, filter, search, updateWebhooksRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create a new webhook.
     * @summary Create a Webhook
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateWebhookRequest} [createWebhookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public createWebhook(fields?: Array<string>, meta?: string, createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).createWebhook(fields, meta, createWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing webhook
     * @summary Delete a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple existing webhooks.
     * @summary Delete Multiple Webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhooks(options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single webhook by unique identifier.
     * @summary Retrieve a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all webhooks.
     * @summary List Webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooks(options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing webhook
     * @summary Update a Webhook
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateWebhookRequest} [createWebhookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhook(id: string, fields?: Array<string>, meta?: string, createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).updateWebhook(id, fields, meta, createWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple webhooks at the same time.
     * @summary Update Multiple Webhooks
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {object} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {UpdateWebhooksRequest} [updateWebhooksRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhooks(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: object, search?: string, updateWebhooksRequest?: UpdateWebhooksRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).updateWebhooks(fields, limit, meta, offset, sort, filter, search, updateWebhooksRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



